// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str =
	include_str!("/Users/tale/Developer/canister/api/prisma/schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder()
		.with_url(url.to_string())
		.build()
		.await
}
pub mod repository {
	use super::_prisma::*;
	use super::*;
	pub mod slug {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::SlugEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Slug(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Slug(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSlug(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Slug(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("slug").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Slug(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("slug").build()
			}
		}
	}
	pub mod aliases {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<String>) -> WhereParam {
			WhereParam::AliasesEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Aliases(direction)
		}
		pub fn has(value: String) -> WhereParam {
			WhereParam::Aliases(_prisma::read_filters::StringListFilter::Has(value))
		}
		pub fn has_every(value: Vec<String>) -> WhereParam {
			WhereParam::Aliases(_prisma::read_filters::StringListFilter::HasEvery(value))
		}
		pub fn has_some(value: Vec<String>) -> WhereParam {
			WhereParam::Aliases(_prisma::read_filters::StringListFilter::HasSome(value))
		}
		pub fn is_empty(value: bool) -> WhereParam {
			WhereParam::Aliases(_prisma::read_filters::StringListFilter::IsEmpty(value))
		}
		pub fn push(value: Vec<String>) -> SetParam {
			SetParam::PushAliases(value)
		}
		pub struct Set(pub Vec<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetAliases(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Aliases(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("aliases").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Aliases(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("aliases").build()
			}
		}
	}
	pub mod tier {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TierEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Tier(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Tier(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementTier(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementTier(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyTier(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideTier(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTier(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Tier(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("tier").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Tier(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("tier").build()
			}
		}
	}
	pub mod package_count {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::PackageCountEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::PackageCount(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::PackageCount(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementPackageCount(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementPackageCount(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyPackageCount(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DividePackageCount(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetPackageCount(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PackageCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("packageCount").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PackageCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("packageCount").build()
			}
		}
	}
	pub mod sections {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<String>) -> WhereParam {
			WhereParam::SectionsEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Sections(direction)
		}
		pub fn has(value: String) -> WhereParam {
			WhereParam::Sections(_prisma::read_filters::StringListFilter::Has(value))
		}
		pub fn has_every(value: Vec<String>) -> WhereParam {
			WhereParam::Sections(_prisma::read_filters::StringListFilter::HasEvery(value))
		}
		pub fn has_some(value: Vec<String>) -> WhereParam {
			WhereParam::Sections(_prisma::read_filters::StringListFilter::HasSome(value))
		}
		pub fn is_empty(value: bool) -> WhereParam {
			WhereParam::Sections(_prisma::read_filters::StringListFilter::IsEmpty(value))
		}
		pub fn push(value: Vec<String>) -> SetParam {
			SetParam::PushSections(value)
		}
		pub struct Set(pub Vec<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSections(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Sections(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sections").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Sections(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sections").build()
			}
		}
	}
	pub mod uri {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::UriEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Uri(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Uri(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUri(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Uri(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uri").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Uri(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uri").build()
			}
		}
	}
	pub mod suite {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::SuiteEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Suite(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Suite(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSuite(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Suite(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("suite").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Suite(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("suite").build()
			}
		}
	}
	pub mod component {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::ComponentEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Component(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Component(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetComponent(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Component(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("component").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Component(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("component").build()
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
	}
	pub mod version {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::VersionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Version(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetVersion(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Version(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("version").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Version(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("version").build()
			}
		}
	}
	pub mod description {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DescriptionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Description(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetDescription(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Description(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("description").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Description(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("description").build()
			}
		}
	}
	pub mod date {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Date(direction)
		}
		pub fn in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::InVec(value))
		}
		pub fn not_in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::NotInVec(value))
		}
		pub fn lt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::Lt(value))
		}
		pub fn lte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::Lte(value))
		}
		pub fn gt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::Gt(value))
		}
		pub fn gte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::Gte(value))
		}
		pub fn not(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::Date(_prisma::read_filters::DateTimeFilter::Not(value))
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetDate(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Date(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("date").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Date(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("date").build()
			}
		}
	}
	pub mod payment_gateway {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::PaymentGatewayEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::PaymentGateway(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::PaymentGateway(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetPaymentGateway(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PaymentGateway(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("paymentGateway").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PaymentGateway(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("paymentGateway").build()
			}
		}
	}
	pub mod sileo_endpoint {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::SileoEndpointEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::SileoEndpoint(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::SileoEndpoint(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSileoEndpoint(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SileoEndpoint(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sileoEndpoint").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SileoEndpoint(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sileoEndpoint").build()
			}
		}
	}
	pub mod is_pruned {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsPrunedEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::IsPruned(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetIsPruned(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsPruned(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("isPruned").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsPruned(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("isPruned").build()
			}
		}
	}
	pub mod origin {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<origin::WhereParam>) -> WhereParam {
			WhereParam::OriginIs(value)
		}
		pub fn is_not(value: Vec<origin::WhereParam>) -> WhereParam {
			WhereParam::OriginIsNot(value)
		}
		pub struct Fetch(pub origin::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<origin::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Origin(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(origin::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: origin::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(origin::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectOrigin(value.0)
			}
		}
		pub enum Include {
			Select(Vec<origin::SelectParam>),
			Include(Vec<origin::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Origin(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("origin");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < origin :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< origin :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<origin::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<origin::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<origin::SelectParam>),
			Include(Vec<origin::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Origin(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("origin");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< origin :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<origin::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<origin::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod origin_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::OriginIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::OriginId(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::OriginId(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetOriginId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::OriginId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("originId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::OriginId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("originId").build()
			}
		}
	}
	pub mod packages {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<package::WhereParam>) -> WhereParam {
			WhereParam::PackagesSome(value)
		}
		pub fn every(value: Vec<package::WhereParam>) -> WhereParam {
			WhereParam::PackagesEvery(value)
		}
		pub fn none(value: Vec<package::WhereParam>) -> WhereParam {
			WhereParam::PackagesNone(value)
		}
		pub struct Fetch(pub package::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<package::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: package::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: package::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Packages(fetch.0)
			}
		}
		pub fn fetch(params: Vec<package::WhereParam>) -> Fetch {
			Fetch(package::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<package::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<package::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectPackages(params)
		}
		pub fn set(params: Vec<package::UniqueWhereParam>) -> SetParam {
			SetParam::SetPackages(params)
		}
		pub struct Connect(pub Vec<package::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectPackages(value.0)
			}
		}
		pub enum Include {
			Select(package::ManyArgs, Vec<package::SelectParam>),
			Include(package::ManyArgs, Vec<package::IncludeParam>),
			Fetch(package::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Packages(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("packages");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < package :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< package :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: package::ManyArgs,
				nested_selections: Vec<package::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: package::ManyArgs,
				nested_selections: Vec<package::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(package::ManyArgs, Vec<package::SelectParam>),
			Include(package::ManyArgs, Vec<package::IncludeParam>),
			Fetch(package::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Packages(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("packages");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< package :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: package::ManyArgs,
				nested_selections: Vec<package::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: package::ManyArgs,
				nested_selections: Vec<package::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub fn create(
		slug: String,
		tier: i32,
		package_count: i32,
		uri: String,
		origin: super::origin::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> (
		String,
		i32,
		i32,
		String,
		super::origin::UniqueWhereParam,
		Vec<SetParam>,
	) {
		(slug, tier, package_count, uri, origin, _params)
	}
	pub fn create_unchecked(
		slug: String,
		tier: i32,
		package_count: i32,
		uri: String,
		origin_id: String,
		_params: Vec<SetParam>,
	) -> (String, i32, i32, String, String, Vec<SetParam>) {
		(slug, tier, package_count, uri, origin_id, _params)
	}
	#[macro_export]
	macro_rules ! _select_repository { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: repository :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: repository :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: repository :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: repository :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { slug , aliases , tier , package_count , sections , uri , suite , component , name , version , description , date , payment_gateway , sileo_endpoint , is_pruned , origin , origin_id , packages } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: repository :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: repository :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: repository :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: repository :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["slug" , "aliases" , "tier" , "packageCount" , "sections" , "uri" , "suite" , "component" , "name" , "version" , "description" , "date" , "paymentGateway" , "sileoEndpoint" , "isPruned" , "origin" , "originId" , "packages"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: repository :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; slug) => { String } ; (@ field_type ; aliases) => { Vec < String > } ; (@ field_type ; tier) => { i32 } ; (@ field_type ; package_count) => { i32 } ; (@ field_type ; sections) => { Vec < String > } ; (@ field_type ; uri) => { String } ; (@ field_type ; suite) => { String } ; (@ field_type ; component) => { Option < String > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; version) => { Option < String > } ; (@ field_type ; description) => { Option < String > } ; (@ field_type ; date) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; payment_gateway) => { Option < String > } ; (@ field_type ; sileo_endpoint) => { Option < String > } ; (@ field_type ; is_pruned) => { bool } ; (@ field_type ; origin : $ selection_mode : ident { $ ($ selections : tt) + }) => { origin :: Data } ; (@ field_type ; origin) => { crate :: prisma :: origin :: Data } ; (@ field_type ; origin_id) => { String } ; (@ field_type ; packages : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < packages :: Data > } ; (@ field_type ; packages) => { Vec < crate :: prisma :: package :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Repository" , available fields are "slug, aliases, tier, package_count, sections, uri, suite, component, name, version, description, date, payment_gateway, sileo_endpoint, is_pruned, origin, origin_id, packages")) } ; (@ field_module ; origin : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: origin :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; packages : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: package :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; slug) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: slug :: Select) } ; (@ selection_field_to_selection_param ; aliases) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: aliases :: Select) } ; (@ selection_field_to_selection_param ; tier) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: tier :: Select) } ; (@ selection_field_to_selection_param ; package_count) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: package_count :: Select) } ; (@ selection_field_to_selection_param ; sections) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: sections :: Select) } ; (@ selection_field_to_selection_param ; uri) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: uri :: Select) } ; (@ selection_field_to_selection_param ; suite) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: suite :: Select) } ; (@ selection_field_to_selection_param ; component) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: component :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: name :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: version :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: description :: Select) } ; (@ selection_field_to_selection_param ; date) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: date :: Select) } ; (@ selection_field_to_selection_param ; payment_gateway) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: payment_gateway :: Select) } ; (@ selection_field_to_selection_param ; sileo_endpoint) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: sileo_endpoint :: Select) } ; (@ selection_field_to_selection_param ; is_pruned) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: is_pruned :: Select) } ; (@ selection_field_to_selection_param ; origin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: origin :: Select :: $ selection_mode ($ crate :: prisma :: origin :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; origin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: origin :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; origin_id) => { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: origin_id :: Select) } ; (@ selection_field_to_selection_param ; packages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: packages :: Select :: $ selection_mode ($ crate :: prisma :: package :: ManyArgs :: new ($ crate :: prisma :: package :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: package :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; packages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: repository :: SelectParam > :: into ($ crate :: prisma :: repository :: packages :: Select :: Fetch ($ crate :: prisma :: package :: ManyArgs :: new ($ crate :: prisma :: package :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: repository :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; slug) => { "slug" } ; (@ field_serde_name ; aliases) => { "aliases" } ; (@ field_serde_name ; tier) => { "tier" } ; (@ field_serde_name ; package_count) => { "packageCount" } ; (@ field_serde_name ; sections) => { "sections" } ; (@ field_serde_name ; uri) => { "uri" } ; (@ field_serde_name ; suite) => { "suite" } ; (@ field_serde_name ; component) => { "component" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; date) => { "date" } ; (@ field_serde_name ; payment_gateway) => { "paymentGateway" } ; (@ field_serde_name ; sileo_endpoint) => { "sileoEndpoint" } ; (@ field_serde_name ; is_pruned) => { "isPruned" } ; (@ field_serde_name ; origin) => { "origin" } ; (@ field_serde_name ; origin_id) => { "originId" } ; (@ field_serde_name ; packages) => { "packages" } ; }
	pub use _select_repository as select;
	pub enum SelectParam {
		Slug(slug::Select),
		Aliases(aliases::Select),
		Tier(tier::Select),
		PackageCount(package_count::Select),
		Sections(sections::Select),
		Uri(uri::Select),
		Suite(suite::Select),
		Component(component::Select),
		Name(name::Select),
		Version(version::Select),
		Description(description::Select),
		Date(date::Select),
		PaymentGateway(payment_gateway::Select),
		SileoEndpoint(sileo_endpoint::Select),
		IsPruned(is_pruned::Select),
		Origin(origin::Select),
		OriginId(origin_id::Select),
		Packages(packages::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Slug(data) => data.to_selection(),
				Self::Aliases(data) => data.to_selection(),
				Self::Tier(data) => data.to_selection(),
				Self::PackageCount(data) => data.to_selection(),
				Self::Sections(data) => data.to_selection(),
				Self::Uri(data) => data.to_selection(),
				Self::Suite(data) => data.to_selection(),
				Self::Component(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::Date(data) => data.to_selection(),
				Self::PaymentGateway(data) => data.to_selection(),
				Self::SileoEndpoint(data) => data.to_selection(),
				Self::IsPruned(data) => data.to_selection(),
				Self::Origin(data) => data.to_selection(),
				Self::OriginId(data) => data.to_selection(),
				Self::Packages(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_repository { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: repository :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: repository :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: repository :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: repository :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { origin , packages } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub slug : String , pub aliases : Vec < String > , pub tier : i32 , pub package_count : i32 , pub sections : Vec < String > , pub uri : String , pub suite : String , pub component : Option < String > , pub name : Option < String > , pub version : Option < String > , pub description : Option < String > , pub date : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub payment_gateway : Option < String > , pub sileo_endpoint : Option < String > , pub is_pruned : bool , pub origin_id : String , $ (pub $ field : $ crate :: prisma :: repository :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (slug) , stringify ! (aliases) , stringify ! (tier) , stringify ! (package_count) , stringify ! (sections) , stringify ! (uri) , stringify ! (suite) , stringify ! (component) , stringify ! (name) , stringify ! (version) , stringify ! (description) , stringify ! (date) , stringify ! (payment_gateway) , stringify ! (sileo_endpoint) , stringify ! (is_pruned) , stringify ! (origin_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; slug) , & self . slug) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; aliases) , & self . aliases) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; tier) , & self . tier) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; package_count) , & self . package_count) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; sections) , & self . sections) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; uri) , & self . uri) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; suite) , & self . suite) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; component) , & self . component) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; version) , & self . version) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; date) , & self . date) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; payment_gateway) , & self . payment_gateway) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; sileo_endpoint) , & self . sileo_endpoint) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; is_pruned) , & self . is_pruned) ? ; state . serialize_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; origin_id) , & self . origin_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , slug , aliases , tier , package_count , sections , uri , suite , component , name , version , description , date , payment_gateway , sileo_endpoint , is_pruned , origin_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; slug) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; aliases) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; tier) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; package_count) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; sections) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; uri) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; suite) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; component) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; version) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; description) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; date) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; payment_gateway) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; sileo_endpoint) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; is_pruned) , ", " , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; origin_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; slug) => Ok (Field :: slug) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; aliases) => Ok (Field :: aliases) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; tier) => Ok (Field :: tier) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; package_count) => Ok (Field :: package_count) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; sections) => Ok (Field :: sections) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; uri) => Ok (Field :: uri) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; suite) => Ok (Field :: suite) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; component) => Ok (Field :: component) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; version) => Ok (Field :: version) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; date) => Ok (Field :: date) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; payment_gateway) => Ok (Field :: payment_gateway) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; sileo_endpoint) => Ok (Field :: sileo_endpoint) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; is_pruned) => Ok (Field :: is_pruned) , $ crate :: prisma :: repository :: include ! (@ field_serde_name ; origin_id) => Ok (Field :: origin_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut slug = None ; let mut aliases = None ; let mut tier = None ; let mut package_count = None ; let mut sections = None ; let mut uri = None ; let mut suite = None ; let mut component = None ; let mut name = None ; let mut version = None ; let mut description = None ; let mut date = None ; let mut payment_gateway = None ; let mut sileo_endpoint = None ; let mut is_pruned = None ; let mut origin_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: slug => { if slug . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; slug))) ; } slug = Some (map . next_value () ?) ; } Field :: aliases => { if aliases . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; aliases))) ; } aliases = Some (map . next_value () ?) ; } Field :: tier => { if tier . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; tier))) ; } tier = Some (map . next_value () ?) ; } Field :: package_count => { if package_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; package_count))) ; } package_count = Some (map . next_value () ?) ; } Field :: sections => { if sections . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; sections))) ; } sections = Some (map . next_value () ?) ; } Field :: uri => { if uri . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; uri))) ; } uri = Some (map . next_value () ?) ; } Field :: suite => { if suite . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; suite))) ; } suite = Some (map . next_value () ?) ; } Field :: component => { if component . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; component))) ; } component = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; version))) ; } version = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } Field :: date => { if date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; date))) ; } date = Some (map . next_value () ?) ; } Field :: payment_gateway => { if payment_gateway . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; payment_gateway))) ; } payment_gateway = Some (map . next_value () ?) ; } Field :: sileo_endpoint => { if sileo_endpoint . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; sileo_endpoint))) ; } sileo_endpoint = Some (map . next_value () ?) ; } Field :: is_pruned => { if is_pruned . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; is_pruned))) ; } is_pruned = Some (map . next_value () ?) ; } Field :: origin_id => { if origin_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; origin_id))) ; } origin_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; $ field))) ? ;) * let slug = slug . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; slug))) ? ; let aliases = aliases . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; aliases))) ? ; let tier = tier . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; tier))) ? ; let package_count = package_count . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; package_count))) ? ; let sections = sections . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; sections))) ? ; let uri = uri . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; uri))) ? ; let suite = suite . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; suite))) ? ; let component = component . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; component))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; name))) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; version))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; description))) ? ; let date = date . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; date))) ? ; let payment_gateway = payment_gateway . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; payment_gateway))) ? ; let sileo_endpoint = sileo_endpoint . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; sileo_endpoint))) ? ; let is_pruned = is_pruned . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; is_pruned))) ? ; let origin_id = origin_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: repository :: include ! (@ field_serde_name ; origin_id))) ? ; Ok (Data { slug , aliases , tier , package_count , sections , uri , suite , component , name , version , description , date , payment_gateway , sileo_endpoint , is_pruned , origin_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["slug" , "aliases" , "tier" , "packageCount" , "sections" , "uri" , "suite" , "component" , "name" , "version" , "description" , "date" , "paymentGateway" , "sileoEndpoint" , "isPruned" , "origin" , "originId" , "packages"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: repository :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; origin : $ selection_mode : ident { $ ($ selections : tt) + }) => { origin :: Data } ; (@ field_type ; origin) => { crate :: prisma :: origin :: Data } ; (@ field_type ; packages : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < packages :: Data > } ; (@ field_type ; packages) => { Vec < crate :: prisma :: package :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Repository" , available relations are "origin, packages")) } ; (@ field_module ; origin : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: origin :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; packages : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: package :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; origin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: repository :: IncludeParam > :: into ($ crate :: prisma :: repository :: origin :: Include :: $ selection_mode ($ crate :: prisma :: origin :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; origin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: repository :: IncludeParam > :: into ($ crate :: prisma :: repository :: origin :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; packages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: repository :: IncludeParam > :: into ($ crate :: prisma :: repository :: packages :: Include :: $ selection_mode ($ crate :: prisma :: package :: ManyArgs :: new ($ crate :: prisma :: package :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: package :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; packages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: repository :: IncludeParam > :: into ($ crate :: prisma :: repository :: packages :: Include :: Fetch ($ crate :: prisma :: package :: ManyArgs :: new ($ crate :: prisma :: package :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: repository :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; slug) => { "slug" } ; (@ field_serde_name ; aliases) => { "aliases" } ; (@ field_serde_name ; tier) => { "tier" } ; (@ field_serde_name ; package_count) => { "packageCount" } ; (@ field_serde_name ; sections) => { "sections" } ; (@ field_serde_name ; uri) => { "uri" } ; (@ field_serde_name ; suite) => { "suite" } ; (@ field_serde_name ; component) => { "component" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; date) => { "date" } ; (@ field_serde_name ; payment_gateway) => { "paymentGateway" } ; (@ field_serde_name ; sileo_endpoint) => { "sileoEndpoint" } ; (@ field_serde_name ; is_pruned) => { "isPruned" } ; (@ field_serde_name ; origin) => { "origin" } ; (@ field_serde_name ; origin_id) => { "originId" } ; (@ field_serde_name ; packages) => { "packages" } ; }
	pub use _include_repository as include;
	pub enum IncludeParam {
		Slug(slug::Include),
		Aliases(aliases::Include),
		Tier(tier::Include),
		PackageCount(package_count::Include),
		Sections(sections::Include),
		Uri(uri::Include),
		Suite(suite::Include),
		Component(component::Include),
		Name(name::Include),
		Version(version::Include),
		Description(description::Include),
		Date(date::Include),
		PaymentGateway(payment_gateway::Include),
		SileoEndpoint(sileo_endpoint::Include),
		IsPruned(is_pruned::Include),
		Origin(origin::Include),
		OriginId(origin_id::Include),
		Packages(packages::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Slug(data) => data.to_selection(),
				Self::Aliases(data) => data.to_selection(),
				Self::Tier(data) => data.to_selection(),
				Self::PackageCount(data) => data.to_selection(),
				Self::Sections(data) => data.to_selection(),
				Self::Uri(data) => data.to_selection(),
				Self::Suite(data) => data.to_selection(),
				Self::Component(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::Date(data) => data.to_selection(),
				Self::PaymentGateway(data) => data.to_selection(),
				Self::SileoEndpoint(data) => data.to_selection(),
				Self::IsPruned(data) => data.to_selection(),
				Self::Origin(data) => data.to_selection(),
				Self::OriginId(data) => data.to_selection(),
				Self::Packages(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "slug")]
		pub slug: String,
		#[serde(rename = "aliases")]
		pub aliases: Vec<String>,
		#[serde(rename = "tier")]
		pub tier: i32,
		#[serde(rename = "packageCount")]
		pub package_count: i32,
		#[serde(rename = "sections")]
		pub sections: Vec<String>,
		#[serde(rename = "uri")]
		pub uri: String,
		#[serde(rename = "suite")]
		pub suite: String,
		#[serde(rename = "component")]
		pub component: Option<String>,
		#[serde(rename = "name")]
		pub name: Option<String>,
		#[serde(rename = "version")]
		pub version: Option<String>,
		#[serde(rename = "description")]
		pub description: Option<String>,
		#[serde(rename = "date")]
		pub date: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
		#[serde(rename = "paymentGateway")]
		pub payment_gateway: Option<String>,
		#[serde(rename = "sileoEndpoint")]
		pub sileo_endpoint: Option<String>,
		#[serde(rename = "isPruned")]
		pub is_pruned: bool,
		#[serde(rename = "origin")]
		pub origin: Option<Box<super::origin::Data>>,
		#[serde(rename = "originId")]
		pub origin_id: String,
		#[serde(rename = "packages")]
		pub packages: Option<Vec<super::package::Data>>,
	}
	impl Data {
		pub fn origin(
			&self,
		) -> Result<&super::origin::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.origin
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(origin),
				))
				.map(|v| v.as_ref())
		}
		pub fn packages(
			&self,
		) -> Result<&Vec<super::package::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.packages
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(packages),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Origin(super::origin::UniqueArgs),
		Packages(super::package::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Origin(args) => {
					let mut selections = < super :: origin :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("origin");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Packages(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: package :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("packages");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetSlug(String),
		SetAliases(Vec<String>),
		PushAliases(Vec<String>),
		SetTier(i32),
		IncrementTier(i32),
		DecrementTier(i32),
		MultiplyTier(i32),
		DivideTier(i32),
		SetPackageCount(i32),
		IncrementPackageCount(i32),
		DecrementPackageCount(i32),
		MultiplyPackageCount(i32),
		DividePackageCount(i32),
		SetSections(Vec<String>),
		PushSections(Vec<String>),
		SetUri(String),
		SetSuite(String),
		SetComponent(Option<String>),
		SetName(Option<String>),
		SetVersion(Option<String>),
		SetDescription(Option<String>),
		SetDate(
			Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		),
		SetPaymentGateway(Option<String>),
		SetSileoEndpoint(Option<String>),
		SetIsPruned(bool),
		ConnectOrigin(super::origin::UniqueWhereParam),
		SetOriginId(String),
		ConnectPackages(Vec<super::package::UniqueWhereParam>),
		DisconnectPackages(Vec<super::package::UniqueWhereParam>),
		SetPackages(Vec<super::package::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetSlug(value) => (
					"slug".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetAliases(value) => (
					"aliases".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|v| ::prisma_client_rust::PrismaValue::String(v))
							.collect(),
					),
				),
				SetParam::PushAliases(value) => (
					"aliases".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"push".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				SetParam::SetTier(value) => (
					"tier".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementTier(value) => (
					"tier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementTier(value) => (
					"tier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyTier(value) => (
					"tier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideTier(value) => (
					"tier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetPackageCount(value) => (
					"packageCount".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementPackageCount(value) => (
					"packageCount".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementPackageCount(value) => (
					"packageCount".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyPackageCount(value) => (
					"packageCount".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DividePackageCount(value) => (
					"packageCount".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetSections(value) => (
					"sections".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|v| ::prisma_client_rust::PrismaValue::String(v))
							.collect(),
					),
				),
				SetParam::PushSections(value) => (
					"sections".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"push".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				SetParam::SetUri(value) => (
					"uri".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetSuite(value) => (
					"suite".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetComponent(value) => (
					"component".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetName(value) => (
					"name".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetVersion(value) => (
					"version".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetDescription(value) => (
					"description".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetDate(value) => (
					"date".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetPaymentGateway(value) => (
					"paymentGateway".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetSileoEndpoint(value) => (
					"sileoEndpoint".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetIsPruned(value) => (
					"isPruned".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::ConnectOrigin(where_param) => (
					"origin".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::origin::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetOriginId(value) => (
					"originId".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectPackages(where_params) => (
					"packages".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::package::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectPackages(where_params) => (
					"packages".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::package::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetPackages(where_params) => (
					"packages".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::package::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Slug(::prisma_client_rust::Direction),
		Aliases(::prisma_client_rust::Direction),
		Tier(::prisma_client_rust::Direction),
		PackageCount(::prisma_client_rust::Direction),
		Sections(::prisma_client_rust::Direction),
		Uri(::prisma_client_rust::Direction),
		Suite(::prisma_client_rust::Direction),
		Component(::prisma_client_rust::Direction),
		Name(::prisma_client_rust::Direction),
		Version(::prisma_client_rust::Direction),
		Description(::prisma_client_rust::Direction),
		Date(::prisma_client_rust::Direction),
		PaymentGateway(::prisma_client_rust::Direction),
		SileoEndpoint(::prisma_client_rust::Direction),
		IsPruned(::prisma_client_rust::Direction),
		OriginId(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Slug(direction) => (
					"slug".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Aliases(direction) => (
					"aliases".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Tier(direction) => (
					"tier".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::PackageCount(direction) => (
					"packageCount".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Sections(direction) => (
					"sections".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Uri(direction) => (
					"uri".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Suite(direction) => (
					"suite".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Component(direction) => (
					"component".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Name(direction) => (
					"name".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Version(direction) => (
					"version".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Description(direction) => (
					"description".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Date(direction) => (
					"date".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::PaymentGateway(direction) => (
					"paymentGateway".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::SileoEndpoint(direction) => (
					"sileoEndpoint".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::IsPruned(direction) => (
					"isPruned".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::OriginId(direction) => (
					"originId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		SlugEquals(String),
		Slug(_prisma::read_filters::StringFilter),
		AliasesEquals(Vec<String>),
		Aliases(_prisma::read_filters::StringListFilter),
		TierEquals(i32),
		Tier(_prisma::read_filters::IntFilter),
		PackageCountEquals(i32),
		PackageCount(_prisma::read_filters::IntFilter),
		SectionsEquals(Vec<String>),
		Sections(_prisma::read_filters::StringListFilter),
		UriEquals(String),
		Uri(_prisma::read_filters::StringFilter),
		SuiteEquals(String),
		Suite(_prisma::read_filters::StringFilter),
		ComponentEquals(Option<String>),
		Component(_prisma::read_filters::StringFilter),
		NameEquals(Option<String>),
		Name(_prisma::read_filters::StringFilter),
		VersionEquals(Option<String>),
		Version(_prisma::read_filters::StringFilter),
		DescriptionEquals(Option<String>),
		Description(_prisma::read_filters::StringFilter),
		DateEquals(
			Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		),
		Date(_prisma::read_filters::DateTimeFilter),
		PaymentGatewayEquals(Option<String>),
		PaymentGateway(_prisma::read_filters::StringFilter),
		SileoEndpointEquals(Option<String>),
		SileoEndpoint(_prisma::read_filters::StringFilter),
		IsPrunedEquals(bool),
		OriginIs(Vec<super::origin::WhereParam>),
		OriginIsNot(Vec<super::origin::WhereParam>),
		OriginIdEquals(String),
		OriginId(_prisma::read_filters::StringFilter),
		PackagesSome(Vec<super::package::WhereParam>),
		PackagesEvery(Vec<super::package::WhereParam>),
		PackagesNone(Vec<super::package::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::SlugEquals(value) => (
					"slug",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Slug(value) => ("slug", value.into()),
				Self::AliasesEquals(value) => (
					"aliases",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::Aliases(value) => ("aliases", value.into()),
				Self::TierEquals(value) => (
					"tier",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Tier(value) => ("tier", value.into()),
				Self::PackageCountEquals(value) => (
					"packageCount",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::PackageCount(value) => ("packageCount", value.into()),
				Self::SectionsEquals(value) => (
					"sections",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::Sections(value) => ("sections", value.into()),
				Self::UriEquals(value) => (
					"uri",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Uri(value) => ("uri", value.into()),
				Self::SuiteEquals(value) => (
					"suite",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Suite(value) => ("suite", value.into()),
				Self::ComponentEquals(value) => (
					"component",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Component(value) => ("component", value.into()),
				Self::NameEquals(value) => (
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Name(value) => ("name", value.into()),
				Self::VersionEquals(value) => (
					"version",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Version(value) => ("version", value.into()),
				Self::DescriptionEquals(value) => (
					"description",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Description(value) => ("description", value.into()),
				Self::DateEquals(value) => (
					"date",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Date(value) => ("date", value.into()),
				Self::PaymentGatewayEquals(value) => (
					"paymentGateway",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::PaymentGateway(value) => ("paymentGateway", value.into()),
				Self::SileoEndpointEquals(value) => (
					"sileoEndpoint",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::SileoEndpoint(value) => ("sileoEndpoint", value.into()),
				Self::IsPrunedEquals(value) => (
					"isPruned",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::OriginIs(where_params) => (
					"origin",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::OriginIsNot(where_params) => (
					"origin",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::OriginIdEquals(value) => (
					"originId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::OriginId(value) => ("originId", value.into()),
				Self::PackagesSome(where_params) => (
					"packages",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::PackagesEvery(where_params) => (
					"packages",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::PackagesNone(where_params) => (
					"packages",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		SlugEquals(String),
		OriginIdEquals(String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::SlugEquals(value) => Self::SlugEquals(value),
				UniqueWhereParam::OriginIdEquals(value) => Self::OriginIdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Repository";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			[
				"slug",
				"aliases",
				"tier",
				"packageCount",
				"sections",
				"uri",
				"suite",
				"component",
				"name",
				"version",
				"description",
				"date",
				"paymentGateway",
				"sileoEndpoint",
				"isPruned",
				"originId",
			]
			.into_iter()
			.map(|o| {
				let builder = ::prisma_client_rust::Selection::builder(o);
				builder.build()
			})
			.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			slug: String,
			tier: i32,
			package_count: i32,
			uri: String,
			origin: super::origin::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(slug::set(slug));
			_params.push(tier::set(tier));
			_params.push(package_count::set(package_count));
			_params.push(uri::set(uri));
			_params.push(origin::connect(origin));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(String, i32, i32, String, String, Vec<SetParam>)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(slug, tier, package_count, uri, origin_id, mut _params)| {
					_params.push(slug::set(slug));
					_params.push(tier::set(tier));
					_params.push(package_count::set(package_count));
					_params.push(uri::set(uri));
					_params.push(origin_id::set(origin_id));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(slug, tier, package_count, uri, origin, mut _params): (
				String,
				i32,
				i32,
				String,
				super::origin::UniqueWhereParam,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(slug::set(slug));
			_params.push(tier::set(tier));
			_params.push(package_count::set(package_count));
			_params.push(uri::set(uri));
			_params.push(origin::connect(origin));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod origin {
	use super::_prisma::*;
	use super::*;
	pub mod uuid {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UuidEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Uuid(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUuid(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Uuid(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uuid").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Uuid(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uuid").build()
			}
		}
	}
	pub mod hostname {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::HostnameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Hostname(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Hostname(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetHostname(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Hostname(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("hostname").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Hostname(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("hostname").build()
			}
		}
	}
	pub mod release_path {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::ReleasePathEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::ReleasePath(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::ReleasePath(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetReleasePath(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ReleasePath(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("releasePath").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ReleasePath(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("releasePath").build()
			}
		}
	}
	pub mod packages_path {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::PackagesPathEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::PackagesPath(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::PackagesPath(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetPackagesPath(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PackagesPath(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("packagesPath").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PackagesPath(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("packagesPath").build()
			}
		}
	}
	pub mod last_updated {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastUpdatedEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::LastUpdated(direction)
		}
		pub fn in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::InVec(value))
		}
		pub fn not_in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::NotInVec(value))
		}
		pub fn lt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::Lt(value))
		}
		pub fn lte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::Lte(value))
		}
		pub fn gt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::Gt(value))
		}
		pub fn gte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::Gte(value))
		}
		pub fn not(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastUpdated(_prisma::read_filters::DateTimeFilter::Not(value))
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLastUpdated(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LastUpdated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("lastUpdated").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LastUpdated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("lastUpdated").build()
			}
		}
	}
	pub mod has_in_release {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::HasInReleaseEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::HasInRelease(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetHasInRelease(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::HasInRelease(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("hasInRelease").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::HasInRelease(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("hasInRelease").build()
			}
		}
	}
	pub mod has_release_gpg {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::HasReleaseGpgEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::HasReleaseGpg(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetHasReleaseGpg(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::HasReleaseGpg(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("hasReleaseGpg").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::HasReleaseGpg(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("hasReleaseGpg").build()
			}
		}
	}
	pub mod supports_payment_v_1 {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::SupportsPaymentV1Equals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::SupportsPaymentV1(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSupportsPaymentV1(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SupportsPaymentV1(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("supportsPaymentV1").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SupportsPaymentV1(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("supportsPaymentV1").build()
			}
		}
	}
	pub mod supports_payment_v_2 {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::SupportsPaymentV2Equals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::SupportsPaymentV2(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSupportsPaymentV2(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SupportsPaymentV2(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("supportsPaymentV2").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SupportsPaymentV2(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("supportsPaymentV2").build()
			}
		}
	}
	pub mod uses_https {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::UsesHttpsEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::UsesHttps(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUsesHttps(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::UsesHttps(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("usesHttps").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::UsesHttps(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("usesHttps").build()
			}
		}
	}
	pub mod repository {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<repository::WhereParam>) -> WhereParam {
			WhereParam::RepositoryIs(value)
		}
		pub fn is_not(value: Vec<repository::WhereParam>) -> WhereParam {
			WhereParam::RepositoryIsNot(value)
		}
		pub struct Fetch(pub repository::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<repository::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Repository(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(repository::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: repository::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectRepository
		}
		pub struct Connect(repository::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectRepository(value.0)
			}
		}
		pub enum Include {
			Select(Vec<repository::SelectParam>),
			Include(Vec<repository::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Repository(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("repository");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<repository::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<repository::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<repository::SelectParam>),
			Include(Vec<repository::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Repository(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("repository");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<repository::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<repository::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub fn create(
		hostname: String,
		release_path: String,
		packages_path: String,
		last_updated: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		has_in_release: bool,
		has_release_gpg: bool,
		supports_payment_v_1: bool,
		supports_payment_v_2: bool,
		uses_https: bool,
		_params: Vec<SetParam>,
	) -> (
		String,
		String,
		String,
		::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		bool,
		bool,
		bool,
		bool,
		bool,
		Vec<SetParam>,
	) {
		(
			hostname,
			release_path,
			packages_path,
			last_updated,
			has_in_release,
			has_release_gpg,
			supports_payment_v_1,
			supports_payment_v_2,
			uses_https,
			_params,
		)
	}
	pub fn create_unchecked(
		hostname: String,
		release_path: String,
		packages_path: String,
		last_updated: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		has_in_release: bool,
		has_release_gpg: bool,
		supports_payment_v_1: bool,
		supports_payment_v_2: bool,
		uses_https: bool,
		_params: Vec<SetParam>,
	) -> (
		String,
		String,
		String,
		::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		bool,
		bool,
		bool,
		bool,
		bool,
		Vec<SetParam>,
	) {
		(
			hostname,
			release_path,
			packages_path,
			last_updated,
			has_in_release,
			has_release_gpg,
			supports_payment_v_1,
			supports_payment_v_2,
			uses_https,
			_params,
		)
	}
	#[macro_export]
	macro_rules ! _select_origin { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: origin :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: origin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: origin :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: origin :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: origin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: origin :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { uuid , hostname , release_path , packages_path , last_updated , has_in_release , has_release_gpg , supports_payment_v_1 , supports_payment_v_2 , uses_https , repository } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: origin :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: origin :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: origin :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: origin :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["uuid" , "hostname" , "releasePath" , "packagesPath" , "lastUpdated" , "hasInRelease" , "hasReleaseGpg" , "supportsPaymentV1" , "supportsPaymentV2" , "usesHttps" , "repository"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: origin :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; uuid) => { String } ; (@ field_type ; hostname) => { String } ; (@ field_type ; release_path) => { String } ; (@ field_type ; packages_path) => { String } ; (@ field_type ; last_updated) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; has_in_release) => { bool } ; (@ field_type ; has_release_gpg) => { bool } ; (@ field_type ; supports_payment_v_1) => { bool } ; (@ field_type ; supports_payment_v_2) => { bool } ; (@ field_type ; uses_https) => { bool } ; (@ field_type ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < repository :: Data > } ; (@ field_type ; repository) => { Option < crate :: prisma :: repository :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Origin" , available fields are "uuid, hostname, release_path, packages_path, last_updated, has_in_release, has_release_gpg, supports_payment_v_1, supports_payment_v_2, uses_https, repository")) } ; (@ field_module ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: repository :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; uuid) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: uuid :: Select) } ; (@ selection_field_to_selection_param ; hostname) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: hostname :: Select) } ; (@ selection_field_to_selection_param ; release_path) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: release_path :: Select) } ; (@ selection_field_to_selection_param ; packages_path) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: packages_path :: Select) } ; (@ selection_field_to_selection_param ; last_updated) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: last_updated :: Select) } ; (@ selection_field_to_selection_param ; has_in_release) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: has_in_release :: Select) } ; (@ selection_field_to_selection_param ; has_release_gpg) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: has_release_gpg :: Select) } ; (@ selection_field_to_selection_param ; supports_payment_v_1) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: supports_payment_v_1 :: Select) } ; (@ selection_field_to_selection_param ; supports_payment_v_2) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: supports_payment_v_2 :: Select) } ; (@ selection_field_to_selection_param ; uses_https) => { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: uses_https :: Select) } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: repository :: Select :: $ selection_mode ($ crate :: prisma :: repository :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: origin :: SelectParam > :: into ($ crate :: prisma :: origin :: repository :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: origin :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; hostname) => { "hostname" } ; (@ field_serde_name ; release_path) => { "releasePath" } ; (@ field_serde_name ; packages_path) => { "packagesPath" } ; (@ field_serde_name ; last_updated) => { "lastUpdated" } ; (@ field_serde_name ; has_in_release) => { "hasInRelease" } ; (@ field_serde_name ; has_release_gpg) => { "hasReleaseGpg" } ; (@ field_serde_name ; supports_payment_v_1) => { "supportsPaymentV1" } ; (@ field_serde_name ; supports_payment_v_2) => { "supportsPaymentV2" } ; (@ field_serde_name ; uses_https) => { "usesHttps" } ; (@ field_serde_name ; repository) => { "repository" } ; }
	pub use _select_origin as select;
	pub enum SelectParam {
		Uuid(uuid::Select),
		Hostname(hostname::Select),
		ReleasePath(release_path::Select),
		PackagesPath(packages_path::Select),
		LastUpdated(last_updated::Select),
		HasInRelease(has_in_release::Select),
		HasReleaseGpg(has_release_gpg::Select),
		SupportsPaymentV1(supports_payment_v_1::Select),
		SupportsPaymentV2(supports_payment_v_2::Select),
		UsesHttps(uses_https::Select),
		Repository(repository::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Uuid(data) => data.to_selection(),
				Self::Hostname(data) => data.to_selection(),
				Self::ReleasePath(data) => data.to_selection(),
				Self::PackagesPath(data) => data.to_selection(),
				Self::LastUpdated(data) => data.to_selection(),
				Self::HasInRelease(data) => data.to_selection(),
				Self::HasReleaseGpg(data) => data.to_selection(),
				Self::SupportsPaymentV1(data) => data.to_selection(),
				Self::SupportsPaymentV2(data) => data.to_selection(),
				Self::UsesHttps(data) => data.to_selection(),
				Self::Repository(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_origin { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: origin :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: origin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: origin :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: origin :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: origin :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: origin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: origin :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: origin :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { repository } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub uuid : String , pub hostname : String , pub release_path : String , pub packages_path : String , pub last_updated : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub has_in_release : bool , pub has_release_gpg : bool , pub supports_payment_v_1 : bool , pub supports_payment_v_2 : bool , pub uses_https : bool , $ (pub $ field : $ crate :: prisma :: origin :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (uuid) , stringify ! (hostname) , stringify ! (release_path) , stringify ! (packages_path) , stringify ! (last_updated) , stringify ! (has_in_release) , stringify ! (has_release_gpg) , stringify ! (supports_payment_v_1) , stringify ! (supports_payment_v_2) , stringify ! (uses_https)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; uuid) , & self . uuid) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; hostname) , & self . hostname) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; release_path) , & self . release_path) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; packages_path) , & self . packages_path) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; last_updated) , & self . last_updated) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_in_release) , & self . has_in_release) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_release_gpg) , & self . has_release_gpg) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_1) , & self . supports_payment_v_1) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_2) , & self . supports_payment_v_2) ? ; state . serialize_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; uses_https) , & self . uses_https) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , uuid , hostname , release_path , packages_path , last_updated , has_in_release , has_release_gpg , supports_payment_v_1 , supports_payment_v_2 , uses_https } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; uuid) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; hostname) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; release_path) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; packages_path) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; last_updated) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_in_release) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_release_gpg) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_1) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_2) , ", " , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; uses_https) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; uuid) => Ok (Field :: uuid) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; hostname) => Ok (Field :: hostname) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; release_path) => Ok (Field :: release_path) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; packages_path) => Ok (Field :: packages_path) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; last_updated) => Ok (Field :: last_updated) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_in_release) => Ok (Field :: has_in_release) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_release_gpg) => Ok (Field :: has_release_gpg) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_1) => Ok (Field :: supports_payment_v_1) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_2) => Ok (Field :: supports_payment_v_2) , $ crate :: prisma :: origin :: include ! (@ field_serde_name ; uses_https) => Ok (Field :: uses_https) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut uuid = None ; let mut hostname = None ; let mut release_path = None ; let mut packages_path = None ; let mut last_updated = None ; let mut has_in_release = None ; let mut has_release_gpg = None ; let mut supports_payment_v_1 = None ; let mut supports_payment_v_2 = None ; let mut uses_https = None ; while let Some (key) = map . next_key () ? { match key { Field :: uuid => { if uuid . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; uuid))) ; } uuid = Some (map . next_value () ?) ; } Field :: hostname => { if hostname . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; hostname))) ; } hostname = Some (map . next_value () ?) ; } Field :: release_path => { if release_path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; release_path))) ; } release_path = Some (map . next_value () ?) ; } Field :: packages_path => { if packages_path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; packages_path))) ; } packages_path = Some (map . next_value () ?) ; } Field :: last_updated => { if last_updated . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; last_updated))) ; } last_updated = Some (map . next_value () ?) ; } Field :: has_in_release => { if has_in_release . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_in_release))) ; } has_in_release = Some (map . next_value () ?) ; } Field :: has_release_gpg => { if has_release_gpg . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_release_gpg))) ; } has_release_gpg = Some (map . next_value () ?) ; } Field :: supports_payment_v_1 => { if supports_payment_v_1 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_1))) ; } supports_payment_v_1 = Some (map . next_value () ?) ; } Field :: supports_payment_v_2 => { if supports_payment_v_2 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_2))) ; } supports_payment_v_2 = Some (map . next_value () ?) ; } Field :: uses_https => { if uses_https . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; uses_https))) ; } uses_https = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; $ field))) ? ;) * let uuid = uuid . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; uuid))) ? ; let hostname = hostname . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; hostname))) ? ; let release_path = release_path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; release_path))) ? ; let packages_path = packages_path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; packages_path))) ? ; let last_updated = last_updated . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; last_updated))) ? ; let has_in_release = has_in_release . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_in_release))) ? ; let has_release_gpg = has_release_gpg . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; has_release_gpg))) ? ; let supports_payment_v_1 = supports_payment_v_1 . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_1))) ? ; let supports_payment_v_2 = supports_payment_v_2 . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; supports_payment_v_2))) ? ; let uses_https = uses_https . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: origin :: include ! (@ field_serde_name ; uses_https))) ? ; Ok (Data { uuid , hostname , release_path , packages_path , last_updated , has_in_release , has_release_gpg , supports_payment_v_1 , supports_payment_v_2 , uses_https , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["uuid" , "hostname" , "releasePath" , "packagesPath" , "lastUpdated" , "hasInRelease" , "hasReleaseGpg" , "supportsPaymentV1" , "supportsPaymentV2" , "usesHttps" , "repository"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: origin :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < repository :: Data > } ; (@ field_type ; repository) => { Option < crate :: prisma :: repository :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Origin" , available relations are "repository")) } ; (@ field_module ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: repository :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: origin :: IncludeParam > :: into ($ crate :: prisma :: origin :: repository :: Include :: $ selection_mode ($ crate :: prisma :: repository :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: origin :: IncludeParam > :: into ($ crate :: prisma :: origin :: repository :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: origin :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; hostname) => { "hostname" } ; (@ field_serde_name ; release_path) => { "releasePath" } ; (@ field_serde_name ; packages_path) => { "packagesPath" } ; (@ field_serde_name ; last_updated) => { "lastUpdated" } ; (@ field_serde_name ; has_in_release) => { "hasInRelease" } ; (@ field_serde_name ; has_release_gpg) => { "hasReleaseGpg" } ; (@ field_serde_name ; supports_payment_v_1) => { "supportsPaymentV1" } ; (@ field_serde_name ; supports_payment_v_2) => { "supportsPaymentV2" } ; (@ field_serde_name ; uses_https) => { "usesHttps" } ; (@ field_serde_name ; repository) => { "repository" } ; }
	pub use _include_origin as include;
	pub enum IncludeParam {
		Uuid(uuid::Include),
		Hostname(hostname::Include),
		ReleasePath(release_path::Include),
		PackagesPath(packages_path::Include),
		LastUpdated(last_updated::Include),
		HasInRelease(has_in_release::Include),
		HasReleaseGpg(has_release_gpg::Include),
		SupportsPaymentV1(supports_payment_v_1::Include),
		SupportsPaymentV2(supports_payment_v_2::Include),
		UsesHttps(uses_https::Include),
		Repository(repository::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Uuid(data) => data.to_selection(),
				Self::Hostname(data) => data.to_selection(),
				Self::ReleasePath(data) => data.to_selection(),
				Self::PackagesPath(data) => data.to_selection(),
				Self::LastUpdated(data) => data.to_selection(),
				Self::HasInRelease(data) => data.to_selection(),
				Self::HasReleaseGpg(data) => data.to_selection(),
				Self::SupportsPaymentV1(data) => data.to_selection(),
				Self::SupportsPaymentV2(data) => data.to_selection(),
				Self::UsesHttps(data) => data.to_selection(),
				Self::Repository(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "uuid")]
		pub uuid: String,
		#[serde(rename = "hostname")]
		pub hostname: String,
		#[serde(rename = "releasePath")]
		pub release_path: String,
		#[serde(rename = "packagesPath")]
		pub packages_path: String,
		#[serde(rename = "lastUpdated")]
		pub last_updated:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "hasInRelease")]
		pub has_in_release: bool,
		#[serde(rename = "hasReleaseGpg")]
		pub has_release_gpg: bool,
		#[serde(rename = "supportsPaymentV1")]
		pub supports_payment_v_1: bool,
		#[serde(rename = "supportsPaymentV2")]
		pub supports_payment_v_2: bool,
		#[serde(rename = "usesHttps")]
		pub uses_https: bool,
		#[serde(
			rename = "repository",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		pub repository: Option<Option<Box<super::repository::Data>>>,
	}
	impl Data {
		pub fn repository(
			&self,
		) -> Result<Option<&super::repository::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.repository
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(repository),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Repository(super::repository::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Repository(args) => {
					let mut selections = < super :: repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("repository");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetUuid(String),
		SetHostname(String),
		SetReleasePath(String),
		SetPackagesPath(String),
		SetLastUpdated(
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		),
		SetHasInRelease(bool),
		SetHasReleaseGpg(bool),
		SetSupportsPaymentV1(bool),
		SetSupportsPaymentV2(bool),
		SetUsesHttps(bool),
		ConnectRepository(super::repository::UniqueWhereParam),
		DisconnectRepository,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetUuid(value) => (
					"uuid".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetHostname(value) => (
					"hostname".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetReleasePath(value) => (
					"releasePath".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetPackagesPath(value) => (
					"packagesPath".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetLastUpdated(value) => (
					"lastUpdated".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				),
				SetParam::SetHasInRelease(value) => (
					"hasInRelease".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::SetHasReleaseGpg(value) => (
					"hasReleaseGpg".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::SetSupportsPaymentV1(value) => (
					"supportsPaymentV1".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::SetSupportsPaymentV2(value) => (
					"supportsPaymentV2".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::SetUsesHttps(value) => (
					"usesHttps".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::ConnectRepository(where_param) => (
					"repository".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::repository::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectRepository => (
					"repository".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Uuid(::prisma_client_rust::Direction),
		Hostname(::prisma_client_rust::Direction),
		ReleasePath(::prisma_client_rust::Direction),
		PackagesPath(::prisma_client_rust::Direction),
		LastUpdated(::prisma_client_rust::Direction),
		HasInRelease(::prisma_client_rust::Direction),
		HasReleaseGpg(::prisma_client_rust::Direction),
		SupportsPaymentV1(::prisma_client_rust::Direction),
		SupportsPaymentV2(::prisma_client_rust::Direction),
		UsesHttps(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Uuid(direction) => (
					"uuid".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Hostname(direction) => (
					"hostname".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::ReleasePath(direction) => (
					"releasePath".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::PackagesPath(direction) => (
					"packagesPath".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::LastUpdated(direction) => (
					"lastUpdated".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::HasInRelease(direction) => (
					"hasInRelease".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::HasReleaseGpg(direction) => (
					"hasReleaseGpg".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::SupportsPaymentV1(direction) => (
					"supportsPaymentV1".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::SupportsPaymentV2(direction) => (
					"supportsPaymentV2".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::UsesHttps(direction) => (
					"usesHttps".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		UuidEquals(String),
		Uuid(_prisma::read_filters::StringFilter),
		HostnameEquals(String),
		Hostname(_prisma::read_filters::StringFilter),
		ReleasePathEquals(String),
		ReleasePath(_prisma::read_filters::StringFilter),
		PackagesPathEquals(String),
		PackagesPath(_prisma::read_filters::StringFilter),
		LastUpdatedEquals(
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		),
		LastUpdated(_prisma::read_filters::DateTimeFilter),
		HasInReleaseEquals(bool),
		HasReleaseGpgEquals(bool),
		SupportsPaymentV1Equals(bool),
		SupportsPaymentV2Equals(bool),
		UsesHttpsEquals(bool),
		RepositoryIs(Vec<super::repository::WhereParam>),
		RepositoryIsNot(Vec<super::repository::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::UuidEquals(value) => (
					"uuid",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Uuid(value) => ("uuid", value.into()),
				Self::HostnameEquals(value) => (
					"hostname",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Hostname(value) => ("hostname", value.into()),
				Self::ReleasePathEquals(value) => (
					"releasePath",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::ReleasePath(value) => ("releasePath", value.into()),
				Self::PackagesPathEquals(value) => (
					"packagesPath",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::PackagesPath(value) => ("packagesPath", value.into()),
				Self::LastUpdatedEquals(value) => (
					"lastUpdated",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				),
				Self::LastUpdated(value) => ("lastUpdated", value.into()),
				Self::HasInReleaseEquals(value) => (
					"hasInRelease",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::HasReleaseGpgEquals(value) => (
					"hasReleaseGpg",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::SupportsPaymentV1Equals(value) => (
					"supportsPaymentV1",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::SupportsPaymentV2Equals(value) => (
					"supportsPaymentV2",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::UsesHttpsEquals(value) => (
					"usesHttps",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::RepositoryIs(where_params) => (
					"repository",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::RepositoryIsNot(where_params) => (
					"repository",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UuidEquals(String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UuidEquals(value) => Self::UuidEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Origin";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			[
				"uuid",
				"hostname",
				"releasePath",
				"packagesPath",
				"lastUpdated",
				"hasInRelease",
				"hasReleaseGpg",
				"supportsPaymentV1",
				"supportsPaymentV2",
				"usesHttps",
			]
			.into_iter()
			.map(|o| {
				let builder = ::prisma_client_rust::Selection::builder(o);
				builder.build()
			})
			.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			hostname: String,
			release_path: String,
			packages_path: String,
			last_updated: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			has_in_release: bool,
			has_release_gpg: bool,
			supports_payment_v_1: bool,
			supports_payment_v_2: bool,
			uses_https: bool,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(hostname::set(hostname));
			_params.push(release_path::set(release_path));
			_params.push(packages_path::set(packages_path));
			_params.push(last_updated::set(last_updated));
			_params.push(has_in_release::set(has_in_release));
			_params.push(has_release_gpg::set(has_release_gpg));
			_params.push(supports_payment_v_1::set(supports_payment_v_1));
			_params.push(supports_payment_v_2::set(supports_payment_v_2));
			_params.push(uses_https::set(uses_https));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(
				String,
				String,
				String,
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
				bool,
				bool,
				bool,
				bool,
				bool,
				Vec<SetParam>,
			)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(
					|(
						hostname,
						release_path,
						packages_path,
						last_updated,
						has_in_release,
						has_release_gpg,
						supports_payment_v_1,
						supports_payment_v_2,
						uses_https,
						mut _params,
					)| {
						_params.push(hostname::set(hostname));
						_params.push(release_path::set(release_path));
						_params.push(packages_path::set(packages_path));
						_params.push(last_updated::set(last_updated));
						_params.push(has_in_release::set(has_in_release));
						_params.push(has_release_gpg::set(has_release_gpg));
						_params.push(supports_payment_v_1::set(supports_payment_v_1));
						_params.push(supports_payment_v_2::set(supports_payment_v_2));
						_params.push(uses_https::set(uses_https));
						_params
					},
				)
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(
				hostname,
				release_path,
				packages_path,
				last_updated,
				has_in_release,
				has_release_gpg,
				supports_payment_v_1,
				supports_payment_v_2,
				uses_https,
				mut _params,
			): (
				String,
				String,
				String,
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
				bool,
				bool,
				bool,
				bool,
				bool,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(hostname::set(hostname));
			_params.push(release_path::set(release_path));
			_params.push(packages_path::set(packages_path));
			_params.push(last_updated::set(last_updated));
			_params.push(has_in_release::set(has_in_release));
			_params.push(has_release_gpg::set(has_release_gpg));
			_params.push(supports_payment_v_1::set(supports_payment_v_1));
			_params.push(supports_payment_v_2::set(supports_payment_v_2));
			_params.push(uses_https::set(uses_https));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod package {
	use super::_prisma::*;
	use super::*;
	pub mod uuid {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UuidEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Uuid(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUuid(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Uuid(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uuid").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Uuid(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uuid").build()
			}
		}
	}
	pub mod package {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::PackageEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Package(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Package(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetPackage(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Package(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("package").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Package(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("package").build()
			}
		}
	}
	pub mod is_current {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsCurrentEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::IsCurrent(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetIsCurrent(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsCurrent(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("isCurrent").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsCurrent(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("isCurrent").build()
			}
		}
	}
	pub mod is_pruned {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsPrunedEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::IsPruned(direction)
		}
		pub struct Set(pub bool);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetIsPruned(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsPruned(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("isPruned").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsPruned(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("isPruned").build()
			}
		}
	}
	pub mod repository_tier {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::RepositoryTierEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::RepositoryTier(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::RepositoryTier(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementRepositoryTier(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementRepositoryTier(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyRepositoryTier(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideRepositoryTier(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRepositoryTier(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RepositoryTier(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("repositoryTier").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RepositoryTier(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("repositoryTier").build()
			}
		}
	}
	pub mod repository {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<repository::WhereParam>) -> WhereParam {
			WhereParam::RepositoryIs(value)
		}
		pub fn is_not(value: Vec<repository::WhereParam>) -> WhereParam {
			WhereParam::RepositoryIsNot(value)
		}
		pub struct Fetch(pub repository::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<repository::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Repository(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(repository::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: repository::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(repository::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectRepository(value.0)
			}
		}
		pub enum Include {
			Select(Vec<repository::SelectParam>),
			Include(Vec<repository::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Repository(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("repository");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<repository::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<repository::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<repository::SelectParam>),
			Include(Vec<repository::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Repository(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("repository");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<repository::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<repository::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod repository_slug {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::RepositorySlugEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::RepositorySlug(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRepositorySlug(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RepositorySlug(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("repositorySlug").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RepositorySlug(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("repositorySlug").build()
			}
		}
	}
	pub mod price {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::PriceEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Price(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Price(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetPrice(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Price(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("price").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Price(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("price").build()
			}
		}
	}
	pub mod version {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::VersionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Version(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetVersion(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Version(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("version").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Version(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("version").build()
			}
		}
	}
	pub mod architecture {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::ArchitectureEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Architecture(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Architecture(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetArchitecture(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Architecture(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("architecture").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Architecture(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("architecture").build()
			}
		}
	}
	pub mod filename {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::FilenameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Filename(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Filename(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetFilename(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Filename(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("filename").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Filename(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("filename").build()
			}
		}
	}
	pub mod size {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::SizeEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Size(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Size(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementSize(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementSize(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplySize(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideSize(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSize(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Size(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("size").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Size(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("size").build()
			}
		}
	}
	pub mod sha_256 {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Sha256Equals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Sha256(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Sha256(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSha256(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Sha256(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sha256").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Sha256(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sha256").build()
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
	}
	pub mod description {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DescriptionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Description(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetDescription(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Description(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("description").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Description(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("description").build()
			}
		}
	}
	pub mod author {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::AuthorEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Author(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Author(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetAuthor(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Author(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("author").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Author(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("author").build()
			}
		}
	}
	pub mod maintainer {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::MaintainerEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Maintainer(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Maintainer(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetMaintainer(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Maintainer(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("maintainer").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Maintainer(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("maintainer").build()
			}
		}
	}
	pub mod depiction {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DepictionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Depiction(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Depiction(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetDepiction(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Depiction(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("depiction").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Depiction(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("depiction").build()
			}
		}
	}
	pub mod native_depiction {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::NativeDepictionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::NativeDepiction(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::NativeDepiction(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetNativeDepiction(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NativeDepiction(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("nativeDepiction").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NativeDepiction(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("nativeDepiction").build()
			}
		}
	}
	pub mod sileo_depiction {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::SileoDepictionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::SileoDepiction(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::SileoDepiction(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSileoDepiction(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SileoDepiction(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sileoDepiction").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SileoDepiction(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sileoDepiction").build()
			}
		}
	}
	pub mod header {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::HeaderEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Header(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Header(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetHeader(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Header(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("header").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Header(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("header").build()
			}
		}
	}
	pub mod tint_color {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::TintColorEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::TintColor(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::TintColor(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTintColor(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TintColor(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("tintColor").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TintColor(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("tintColor").build()
			}
		}
	}
	pub mod icon {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::IconEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Icon(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Icon(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetIcon(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Icon(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("icon").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Icon(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("icon").build()
			}
		}
	}
	pub mod section {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::SectionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Section(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Section(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSection(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Section(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("section").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Section(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("section").build()
			}
		}
	}
	pub mod tags {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Vec<String>) -> WhereParam {
			WhereParam::TagsEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Tags(direction)
		}
		pub fn has(value: String) -> WhereParam {
			WhereParam::Tags(_prisma::read_filters::StringListFilter::Has(value))
		}
		pub fn has_every(value: Vec<String>) -> WhereParam {
			WhereParam::Tags(_prisma::read_filters::StringListFilter::HasEvery(value))
		}
		pub fn has_some(value: Vec<String>) -> WhereParam {
			WhereParam::Tags(_prisma::read_filters::StringListFilter::HasSome(value))
		}
		pub fn is_empty(value: bool) -> WhereParam {
			WhereParam::Tags(_prisma::read_filters::StringListFilter::IsEmpty(value))
		}
		pub fn push(value: Vec<String>) -> SetParam {
			SetParam::PushTags(value)
		}
		pub struct Set(pub Vec<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTags(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Tags(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("tags").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Tags(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("tags").build()
			}
		}
	}
	pub mod installed_size {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::InstalledSizeEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::InstalledSize(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::InstalledSize(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementInstalledSize(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementInstalledSize(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyInstalledSize(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideInstalledSize(value)
		}
		pub struct Set(pub Option<i32>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetInstalledSize(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::InstalledSize(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("installedSize").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::InstalledSize(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("installedSize").build()
			}
		}
	}
	pub fn create(
		package: String,
		is_current: bool,
		repository_tier: i32,
		repository: super::repository::UniqueWhereParam,
		price: String,
		version: String,
		architecture: String,
		filename: String,
		size: i32,
		_params: Vec<SetParam>,
	) -> (
		String,
		bool,
		i32,
		super::repository::UniqueWhereParam,
		String,
		String,
		String,
		String,
		i32,
		Vec<SetParam>,
	) {
		(
			package,
			is_current,
			repository_tier,
			repository,
			price,
			version,
			architecture,
			filename,
			size,
			_params,
		)
	}
	pub fn create_unchecked(
		package: String,
		is_current: bool,
		repository_tier: i32,
		repository_slug: String,
		price: String,
		version: String,
		architecture: String,
		filename: String,
		size: i32,
		_params: Vec<SetParam>,
	) -> (
		String,
		bool,
		i32,
		String,
		String,
		String,
		String,
		String,
		i32,
		Vec<SetParam>,
	) {
		(
			package,
			is_current,
			repository_tier,
			repository_slug,
			price,
			version,
			architecture,
			filename,
			size,
			_params,
		)
	}
	#[macro_export]
	macro_rules ! _select_package { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: package :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: package :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: package :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: package :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: package :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: package :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { uuid , package , is_current , is_pruned , repository_tier , repository , repository_slug , price , version , architecture , filename , size , sha_256 , name , description , author , maintainer , depiction , native_depiction , sileo_depiction , header , tint_color , icon , section , tags , installed_size } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: package :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: package :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: package :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: package :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["uuid" , "package" , "isCurrent" , "isPruned" , "repositoryTier" , "repository" , "repositorySlug" , "price" , "version" , "architecture" , "filename" , "size" , "sha256" , "name" , "description" , "author" , "maintainer" , "depiction" , "nativeDepiction" , "sileoDepiction" , "header" , "tintColor" , "icon" , "section" , "tags" , "installedSize"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: package :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; uuid) => { String } ; (@ field_type ; package) => { String } ; (@ field_type ; is_current) => { bool } ; (@ field_type ; is_pruned) => { bool } ; (@ field_type ; repository_tier) => { i32 } ; (@ field_type ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { repository :: Data } ; (@ field_type ; repository) => { crate :: prisma :: repository :: Data } ; (@ field_type ; repository_slug) => { String } ; (@ field_type ; price) => { String } ; (@ field_type ; version) => { String } ; (@ field_type ; architecture) => { String } ; (@ field_type ; filename) => { String } ; (@ field_type ; size) => { i32 } ; (@ field_type ; sha_256) => { Option < String > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; description) => { Option < String > } ; (@ field_type ; author) => { Option < String > } ; (@ field_type ; maintainer) => { Option < String > } ; (@ field_type ; depiction) => { Option < String > } ; (@ field_type ; native_depiction) => { Option < String > } ; (@ field_type ; sileo_depiction) => { Option < String > } ; (@ field_type ; header) => { Option < String > } ; (@ field_type ; tint_color) => { Option < String > } ; (@ field_type ; icon) => { Option < String > } ; (@ field_type ; section) => { Option < String > } ; (@ field_type ; tags) => { Vec < String > } ; (@ field_type ; installed_size) => { Option < i32 > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Package" , available fields are "uuid, package, is_current, is_pruned, repository_tier, repository, repository_slug, price, version, architecture, filename, size, sha_256, name, description, author, maintainer, depiction, native_depiction, sileo_depiction, header, tint_color, icon, section, tags, installed_size")) } ; (@ field_module ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: repository :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; uuid) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: uuid :: Select) } ; (@ selection_field_to_selection_param ; package) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: package :: Select) } ; (@ selection_field_to_selection_param ; is_current) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: is_current :: Select) } ; (@ selection_field_to_selection_param ; is_pruned) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: is_pruned :: Select) } ; (@ selection_field_to_selection_param ; repository_tier) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: repository_tier :: Select) } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: repository :: Select :: $ selection_mode ($ crate :: prisma :: repository :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: repository :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; repository_slug) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: repository_slug :: Select) } ; (@ selection_field_to_selection_param ; price) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: price :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: version :: Select) } ; (@ selection_field_to_selection_param ; architecture) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: architecture :: Select) } ; (@ selection_field_to_selection_param ; filename) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: filename :: Select) } ; (@ selection_field_to_selection_param ; size) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: size :: Select) } ; (@ selection_field_to_selection_param ; sha_256) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: sha_256 :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: description :: Select) } ; (@ selection_field_to_selection_param ; author) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: author :: Select) } ; (@ selection_field_to_selection_param ; maintainer) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: maintainer :: Select) } ; (@ selection_field_to_selection_param ; depiction) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: depiction :: Select) } ; (@ selection_field_to_selection_param ; native_depiction) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: native_depiction :: Select) } ; (@ selection_field_to_selection_param ; sileo_depiction) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: sileo_depiction :: Select) } ; (@ selection_field_to_selection_param ; header) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: header :: Select) } ; (@ selection_field_to_selection_param ; tint_color) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: tint_color :: Select) } ; (@ selection_field_to_selection_param ; icon) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: icon :: Select) } ; (@ selection_field_to_selection_param ; section) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: section :: Select) } ; (@ selection_field_to_selection_param ; tags) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: tags :: Select) } ; (@ selection_field_to_selection_param ; installed_size) => { Into :: < $ crate :: prisma :: package :: SelectParam > :: into ($ crate :: prisma :: package :: installed_size :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: package :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; package) => { "package" } ; (@ field_serde_name ; is_current) => { "isCurrent" } ; (@ field_serde_name ; is_pruned) => { "isPruned" } ; (@ field_serde_name ; repository_tier) => { "repositoryTier" } ; (@ field_serde_name ; repository) => { "repository" } ; (@ field_serde_name ; repository_slug) => { "repositorySlug" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; architecture) => { "architecture" } ; (@ field_serde_name ; filename) => { "filename" } ; (@ field_serde_name ; size) => { "size" } ; (@ field_serde_name ; sha_256) => { "sha256" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; maintainer) => { "maintainer" } ; (@ field_serde_name ; depiction) => { "depiction" } ; (@ field_serde_name ; native_depiction) => { "nativeDepiction" } ; (@ field_serde_name ; sileo_depiction) => { "sileoDepiction" } ; (@ field_serde_name ; header) => { "header" } ; (@ field_serde_name ; tint_color) => { "tintColor" } ; (@ field_serde_name ; icon) => { "icon" } ; (@ field_serde_name ; section) => { "section" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; installed_size) => { "installedSize" } ; }
	pub use _select_package as select;
	pub enum SelectParam {
		Uuid(uuid::Select),
		Package(package::Select),
		IsCurrent(is_current::Select),
		IsPruned(is_pruned::Select),
		RepositoryTier(repository_tier::Select),
		Repository(repository::Select),
		RepositorySlug(repository_slug::Select),
		Price(price::Select),
		Version(version::Select),
		Architecture(architecture::Select),
		Filename(filename::Select),
		Size(size::Select),
		Sha256(sha_256::Select),
		Name(name::Select),
		Description(description::Select),
		Author(author::Select),
		Maintainer(maintainer::Select),
		Depiction(depiction::Select),
		NativeDepiction(native_depiction::Select),
		SileoDepiction(sileo_depiction::Select),
		Header(header::Select),
		TintColor(tint_color::Select),
		Icon(icon::Select),
		Section(section::Select),
		Tags(tags::Select),
		InstalledSize(installed_size::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Uuid(data) => data.to_selection(),
				Self::Package(data) => data.to_selection(),
				Self::IsCurrent(data) => data.to_selection(),
				Self::IsPruned(data) => data.to_selection(),
				Self::RepositoryTier(data) => data.to_selection(),
				Self::Repository(data) => data.to_selection(),
				Self::RepositorySlug(data) => data.to_selection(),
				Self::Price(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::Architecture(data) => data.to_selection(),
				Self::Filename(data) => data.to_selection(),
				Self::Size(data) => data.to_selection(),
				Self::Sha256(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::Author(data) => data.to_selection(),
				Self::Maintainer(data) => data.to_selection(),
				Self::Depiction(data) => data.to_selection(),
				Self::NativeDepiction(data) => data.to_selection(),
				Self::SileoDepiction(data) => data.to_selection(),
				Self::Header(data) => data.to_selection(),
				Self::TintColor(data) => data.to_selection(),
				Self::Icon(data) => data.to_selection(),
				Self::Section(data) => data.to_selection(),
				Self::Tags(data) => data.to_selection(),
				Self::InstalledSize(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_package { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: package :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: package :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: package :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: package :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: package :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: package :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: package :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: package :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { repository } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub uuid : String , pub package : String , pub is_current : bool , pub is_pruned : bool , pub repository_tier : i32 , pub repository_slug : String , pub price : String , pub version : String , pub architecture : String , pub filename : String , pub size : i32 , pub sha_256 : Option < String > , pub name : Option < String > , pub description : Option < String > , pub author : Option < String > , pub maintainer : Option < String > , pub depiction : Option < String > , pub native_depiction : Option < String > , pub sileo_depiction : Option < String > , pub header : Option < String > , pub tint_color : Option < String > , pub icon : Option < String > , pub section : Option < String > , pub tags : Vec < String > , pub installed_size : Option < i32 > , $ (pub $ field : $ crate :: prisma :: package :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (uuid) , stringify ! (package) , stringify ! (is_current) , stringify ! (is_pruned) , stringify ! (repository_tier) , stringify ! (repository_slug) , stringify ! (price) , stringify ! (version) , stringify ! (architecture) , stringify ! (filename) , stringify ! (size) , stringify ! (sha_256) , stringify ! (name) , stringify ! (description) , stringify ! (author) , stringify ! (maintainer) , stringify ! (depiction) , stringify ! (native_depiction) , stringify ! (sileo_depiction) , stringify ! (header) , stringify ! (tint_color) , stringify ! (icon) , stringify ! (section) , stringify ! (tags) , stringify ! (installed_size)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; uuid) , & self . uuid) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; package) , & self . package) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; is_current) , & self . is_current) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; is_pruned) , & self . is_pruned) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_tier) , & self . repository_tier) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_slug) , & self . repository_slug) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; price) , & self . price) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; version) , & self . version) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; architecture) , & self . architecture) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; filename) , & self . filename) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; size) , & self . size) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; sha_256) , & self . sha_256) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; author) , & self . author) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; maintainer) , & self . maintainer) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; depiction) , & self . depiction) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; native_depiction) , & self . native_depiction) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; sileo_depiction) , & self . sileo_depiction) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; header) , & self . header) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; tint_color) , & self . tint_color) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; icon) , & self . icon) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; section) , & self . section) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; tags) , & self . tags) ? ; state . serialize_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; installed_size) , & self . installed_size) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , uuid , package , is_current , is_pruned , repository_tier , repository_slug , price , version , architecture , filename , size , sha_256 , name , description , author , maintainer , depiction , native_depiction , sileo_depiction , header , tint_color , icon , section , tags , installed_size } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: package :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: package :: include ! (@ field_serde_name ; uuid) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; package) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; is_current) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; is_pruned) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_tier) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_slug) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; price) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; version) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; architecture) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; filename) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; size) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; sha_256) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; description) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; author) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; maintainer) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; depiction) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; native_depiction) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; sileo_depiction) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; header) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; tint_color) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; icon) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; section) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; tags) , ", " , $ crate :: prisma :: package :: include ! (@ field_serde_name ; installed_size) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: package :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: package :: include ! (@ field_serde_name ; uuid) => Ok (Field :: uuid) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; package) => Ok (Field :: package) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; is_current) => Ok (Field :: is_current) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; is_pruned) => Ok (Field :: is_pruned) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_tier) => Ok (Field :: repository_tier) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_slug) => Ok (Field :: repository_slug) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; price) => Ok (Field :: price) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; version) => Ok (Field :: version) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; architecture) => Ok (Field :: architecture) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; filename) => Ok (Field :: filename) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; size) => Ok (Field :: size) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; sha_256) => Ok (Field :: sha_256) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; author) => Ok (Field :: author) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; maintainer) => Ok (Field :: maintainer) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; depiction) => Ok (Field :: depiction) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; native_depiction) => Ok (Field :: native_depiction) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; sileo_depiction) => Ok (Field :: sileo_depiction) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; header) => Ok (Field :: header) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; tint_color) => Ok (Field :: tint_color) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; icon) => Ok (Field :: icon) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; section) => Ok (Field :: section) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; tags) => Ok (Field :: tags) , $ crate :: prisma :: package :: include ! (@ field_serde_name ; installed_size) => Ok (Field :: installed_size) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut uuid = None ; let mut package = None ; let mut is_current = None ; let mut is_pruned = None ; let mut repository_tier = None ; let mut repository_slug = None ; let mut price = None ; let mut version = None ; let mut architecture = None ; let mut filename = None ; let mut size = None ; let mut sha_256 = None ; let mut name = None ; let mut description = None ; let mut author = None ; let mut maintainer = None ; let mut depiction = None ; let mut native_depiction = None ; let mut sileo_depiction = None ; let mut header = None ; let mut tint_color = None ; let mut icon = None ; let mut section = None ; let mut tags = None ; let mut installed_size = None ; while let Some (key) = map . next_key () ? { match key { Field :: uuid => { if uuid . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; uuid))) ; } uuid = Some (map . next_value () ?) ; } Field :: package => { if package . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; package))) ; } package = Some (map . next_value () ?) ; } Field :: is_current => { if is_current . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; is_current))) ; } is_current = Some (map . next_value () ?) ; } Field :: is_pruned => { if is_pruned . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; is_pruned))) ; } is_pruned = Some (map . next_value () ?) ; } Field :: repository_tier => { if repository_tier . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_tier))) ; } repository_tier = Some (map . next_value () ?) ; } Field :: repository_slug => { if repository_slug . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_slug))) ; } repository_slug = Some (map . next_value () ?) ; } Field :: price => { if price . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; price))) ; } price = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; version))) ; } version = Some (map . next_value () ?) ; } Field :: architecture => { if architecture . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; architecture))) ; } architecture = Some (map . next_value () ?) ; } Field :: filename => { if filename . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; filename))) ; } filename = Some (map . next_value () ?) ; } Field :: size => { if size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; size))) ; } size = Some (map . next_value () ?) ; } Field :: sha_256 => { if sha_256 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; sha_256))) ; } sha_256 = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } Field :: author => { if author . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; author))) ; } author = Some (map . next_value () ?) ; } Field :: maintainer => { if maintainer . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; maintainer))) ; } maintainer = Some (map . next_value () ?) ; } Field :: depiction => { if depiction . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; depiction))) ; } depiction = Some (map . next_value () ?) ; } Field :: native_depiction => { if native_depiction . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; native_depiction))) ; } native_depiction = Some (map . next_value () ?) ; } Field :: sileo_depiction => { if sileo_depiction . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; sileo_depiction))) ; } sileo_depiction = Some (map . next_value () ?) ; } Field :: header => { if header . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; header))) ; } header = Some (map . next_value () ?) ; } Field :: tint_color => { if tint_color . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; tint_color))) ; } tint_color = Some (map . next_value () ?) ; } Field :: icon => { if icon . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; icon))) ; } icon = Some (map . next_value () ?) ; } Field :: section => { if section . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; section))) ; } section = Some (map . next_value () ?) ; } Field :: tags => { if tags . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; tags))) ; } tags = Some (map . next_value () ?) ; } Field :: installed_size => { if installed_size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; installed_size))) ; } installed_size = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; $ field))) ? ;) * let uuid = uuid . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; uuid))) ? ; let package = package . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; package))) ? ; let is_current = is_current . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; is_current))) ? ; let is_pruned = is_pruned . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; is_pruned))) ? ; let repository_tier = repository_tier . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_tier))) ? ; let repository_slug = repository_slug . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; repository_slug))) ? ; let price = price . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; price))) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; version))) ? ; let architecture = architecture . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; architecture))) ? ; let filename = filename . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; filename))) ? ; let size = size . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; size))) ? ; let sha_256 = sha_256 . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; sha_256))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; name))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; description))) ? ; let author = author . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; author))) ? ; let maintainer = maintainer . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; maintainer))) ? ; let depiction = depiction . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; depiction))) ? ; let native_depiction = native_depiction . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; native_depiction))) ? ; let sileo_depiction = sileo_depiction . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; sileo_depiction))) ? ; let header = header . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; header))) ? ; let tint_color = tint_color . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; tint_color))) ? ; let icon = icon . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; icon))) ? ; let section = section . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; section))) ? ; let tags = tags . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; tags))) ? ; let installed_size = installed_size . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: package :: include ! (@ field_serde_name ; installed_size))) ? ; Ok (Data { uuid , package , is_current , is_pruned , repository_tier , repository_slug , price , version , architecture , filename , size , sha_256 , name , description , author , maintainer , depiction , native_depiction , sileo_depiction , header , tint_color , icon , section , tags , installed_size , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["uuid" , "package" , "isCurrent" , "isPruned" , "repositoryTier" , "repository" , "repositorySlug" , "price" , "version" , "architecture" , "filename" , "size" , "sha256" , "name" , "description" , "author" , "maintainer" , "depiction" , "nativeDepiction" , "sileoDepiction" , "header" , "tintColor" , "icon" , "section" , "tags" , "installedSize"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: package :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { repository :: Data } ; (@ field_type ; repository) => { crate :: prisma :: repository :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Package" , available relations are "repository")) } ; (@ field_module ; repository : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: repository :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: package :: IncludeParam > :: into ($ crate :: prisma :: package :: repository :: Include :: $ selection_mode ($ crate :: prisma :: repository :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repository $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: package :: IncludeParam > :: into ($ crate :: prisma :: package :: repository :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: package :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; package) => { "package" } ; (@ field_serde_name ; is_current) => { "isCurrent" } ; (@ field_serde_name ; is_pruned) => { "isPruned" } ; (@ field_serde_name ; repository_tier) => { "repositoryTier" } ; (@ field_serde_name ; repository) => { "repository" } ; (@ field_serde_name ; repository_slug) => { "repositorySlug" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; architecture) => { "architecture" } ; (@ field_serde_name ; filename) => { "filename" } ; (@ field_serde_name ; size) => { "size" } ; (@ field_serde_name ; sha_256) => { "sha256" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; maintainer) => { "maintainer" } ; (@ field_serde_name ; depiction) => { "depiction" } ; (@ field_serde_name ; native_depiction) => { "nativeDepiction" } ; (@ field_serde_name ; sileo_depiction) => { "sileoDepiction" } ; (@ field_serde_name ; header) => { "header" } ; (@ field_serde_name ; tint_color) => { "tintColor" } ; (@ field_serde_name ; icon) => { "icon" } ; (@ field_serde_name ; section) => { "section" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; installed_size) => { "installedSize" } ; }
	pub use _include_package as include;
	pub enum IncludeParam {
		Uuid(uuid::Include),
		Package(package::Include),
		IsCurrent(is_current::Include),
		IsPruned(is_pruned::Include),
		RepositoryTier(repository_tier::Include),
		Repository(repository::Include),
		RepositorySlug(repository_slug::Include),
		Price(price::Include),
		Version(version::Include),
		Architecture(architecture::Include),
		Filename(filename::Include),
		Size(size::Include),
		Sha256(sha_256::Include),
		Name(name::Include),
		Description(description::Include),
		Author(author::Include),
		Maintainer(maintainer::Include),
		Depiction(depiction::Include),
		NativeDepiction(native_depiction::Include),
		SileoDepiction(sileo_depiction::Include),
		Header(header::Include),
		TintColor(tint_color::Include),
		Icon(icon::Include),
		Section(section::Include),
		Tags(tags::Include),
		InstalledSize(installed_size::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Uuid(data) => data.to_selection(),
				Self::Package(data) => data.to_selection(),
				Self::IsCurrent(data) => data.to_selection(),
				Self::IsPruned(data) => data.to_selection(),
				Self::RepositoryTier(data) => data.to_selection(),
				Self::Repository(data) => data.to_selection(),
				Self::RepositorySlug(data) => data.to_selection(),
				Self::Price(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::Architecture(data) => data.to_selection(),
				Self::Filename(data) => data.to_selection(),
				Self::Size(data) => data.to_selection(),
				Self::Sha256(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::Author(data) => data.to_selection(),
				Self::Maintainer(data) => data.to_selection(),
				Self::Depiction(data) => data.to_selection(),
				Self::NativeDepiction(data) => data.to_selection(),
				Self::SileoDepiction(data) => data.to_selection(),
				Self::Header(data) => data.to_selection(),
				Self::TintColor(data) => data.to_selection(),
				Self::Icon(data) => data.to_selection(),
				Self::Section(data) => data.to_selection(),
				Self::Tags(data) => data.to_selection(),
				Self::InstalledSize(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "uuid")]
		pub uuid: String,
		#[serde(rename = "package")]
		pub package: String,
		#[serde(rename = "isCurrent")]
		pub is_current: bool,
		#[serde(rename = "isPruned")]
		pub is_pruned: bool,
		#[serde(rename = "repositoryTier")]
		pub repository_tier: i32,
		#[serde(rename = "repository")]
		pub repository: Option<Box<super::repository::Data>>,
		#[serde(rename = "repositorySlug")]
		pub repository_slug: String,
		#[serde(rename = "price")]
		pub price: String,
		#[serde(rename = "version")]
		pub version: String,
		#[serde(rename = "architecture")]
		pub architecture: String,
		#[serde(rename = "filename")]
		pub filename: String,
		#[serde(rename = "size")]
		pub size: i32,
		#[serde(rename = "sha256")]
		pub sha_256: Option<String>,
		#[serde(rename = "name")]
		pub name: Option<String>,
		#[serde(rename = "description")]
		pub description: Option<String>,
		#[serde(rename = "author")]
		pub author: Option<String>,
		#[serde(rename = "maintainer")]
		pub maintainer: Option<String>,
		#[serde(rename = "depiction")]
		pub depiction: Option<String>,
		#[serde(rename = "nativeDepiction")]
		pub native_depiction: Option<String>,
		#[serde(rename = "sileoDepiction")]
		pub sileo_depiction: Option<String>,
		#[serde(rename = "header")]
		pub header: Option<String>,
		#[serde(rename = "tintColor")]
		pub tint_color: Option<String>,
		#[serde(rename = "icon")]
		pub icon: Option<String>,
		#[serde(rename = "section")]
		pub section: Option<String>,
		#[serde(rename = "tags")]
		pub tags: Vec<String>,
		#[serde(rename = "installedSize")]
		pub installed_size: Option<i32>,
	}
	impl Data {
		pub fn repository(
			&self,
		) -> Result<&super::repository::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.repository
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(repository),
				))
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Repository(super::repository::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Repository(args) => {
					let mut selections = < super :: repository :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("repository");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetUuid(String),
		SetPackage(String),
		SetIsCurrent(bool),
		SetIsPruned(bool),
		SetRepositoryTier(i32),
		IncrementRepositoryTier(i32),
		DecrementRepositoryTier(i32),
		MultiplyRepositoryTier(i32),
		DivideRepositoryTier(i32),
		ConnectRepository(super::repository::UniqueWhereParam),
		SetRepositorySlug(String),
		SetPrice(String),
		SetVersion(String),
		SetArchitecture(String),
		SetFilename(String),
		SetSize(i32),
		IncrementSize(i32),
		DecrementSize(i32),
		MultiplySize(i32),
		DivideSize(i32),
		SetSha256(Option<String>),
		SetName(Option<String>),
		SetDescription(Option<String>),
		SetAuthor(Option<String>),
		SetMaintainer(Option<String>),
		SetDepiction(Option<String>),
		SetNativeDepiction(Option<String>),
		SetSileoDepiction(Option<String>),
		SetHeader(Option<String>),
		SetTintColor(Option<String>),
		SetIcon(Option<String>),
		SetSection(Option<String>),
		SetTags(Vec<String>),
		PushTags(Vec<String>),
		SetInstalledSize(Option<i32>),
		IncrementInstalledSize(i32),
		DecrementInstalledSize(i32),
		MultiplyInstalledSize(i32),
		DivideInstalledSize(i32),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetUuid(value) => (
					"uuid".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetPackage(value) => (
					"package".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetIsCurrent(value) => (
					"isCurrent".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::SetIsPruned(value) => (
					"isPruned".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				),
				SetParam::SetRepositoryTier(value) => (
					"repositoryTier".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementRepositoryTier(value) => (
					"repositoryTier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementRepositoryTier(value) => (
					"repositoryTier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyRepositoryTier(value) => (
					"repositoryTier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideRepositoryTier(value) => (
					"repositoryTier".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::ConnectRepository(where_param) => (
					"repository".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::repository::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetRepositorySlug(value) => (
					"repositorySlug".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetPrice(value) => (
					"price".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetVersion(value) => (
					"version".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetArchitecture(value) => (
					"architecture".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetFilename(value) => (
					"filename".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetSize(value) => (
					"size".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementSize(value) => (
					"size".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementSize(value) => (
					"size".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplySize(value) => (
					"size".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideSize(value) => (
					"size".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetSha256(value) => (
					"sha256".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetName(value) => (
					"name".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetDescription(value) => (
					"description".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetAuthor(value) => (
					"author".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetMaintainer(value) => (
					"maintainer".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetDepiction(value) => (
					"depiction".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetNativeDepiction(value) => (
					"nativeDepiction".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetSileoDepiction(value) => (
					"sileoDepiction".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetHeader(value) => (
					"header".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetTintColor(value) => (
					"tintColor".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetIcon(value) => (
					"icon".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetSection(value) => (
					"section".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::SetTags(value) => (
					"tags".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|v| ::prisma_client_rust::PrismaValue::String(v))
							.collect(),
					),
				),
				SetParam::PushTags(value) => (
					"tags".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"push".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				SetParam::SetInstalledSize(value) => (
					"installedSize".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
				SetParam::IncrementInstalledSize(value) => (
					"installedSize".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementInstalledSize(value) => (
					"installedSize".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyInstalledSize(value) => (
					"installedSize".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideInstalledSize(value) => (
					"installedSize".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Uuid(::prisma_client_rust::Direction),
		Package(::prisma_client_rust::Direction),
		IsCurrent(::prisma_client_rust::Direction),
		IsPruned(::prisma_client_rust::Direction),
		RepositoryTier(::prisma_client_rust::Direction),
		RepositorySlug(::prisma_client_rust::Direction),
		Price(::prisma_client_rust::Direction),
		Version(::prisma_client_rust::Direction),
		Architecture(::prisma_client_rust::Direction),
		Filename(::prisma_client_rust::Direction),
		Size(::prisma_client_rust::Direction),
		Sha256(::prisma_client_rust::Direction),
		Name(::prisma_client_rust::Direction),
		Description(::prisma_client_rust::Direction),
		Author(::prisma_client_rust::Direction),
		Maintainer(::prisma_client_rust::Direction),
		Depiction(::prisma_client_rust::Direction),
		NativeDepiction(::prisma_client_rust::Direction),
		SileoDepiction(::prisma_client_rust::Direction),
		Header(::prisma_client_rust::Direction),
		TintColor(::prisma_client_rust::Direction),
		Icon(::prisma_client_rust::Direction),
		Section(::prisma_client_rust::Direction),
		Tags(::prisma_client_rust::Direction),
		InstalledSize(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Uuid(direction) => (
					"uuid".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Package(direction) => (
					"package".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::IsCurrent(direction) => (
					"isCurrent".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::IsPruned(direction) => (
					"isPruned".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::RepositoryTier(direction) => (
					"repositoryTier".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::RepositorySlug(direction) => (
					"repositorySlug".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Price(direction) => (
					"price".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Version(direction) => (
					"version".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Architecture(direction) => (
					"architecture".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Filename(direction) => (
					"filename".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Size(direction) => (
					"size".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Sha256(direction) => (
					"sha256".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Name(direction) => (
					"name".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Description(direction) => (
					"description".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Author(direction) => (
					"author".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Maintainer(direction) => (
					"maintainer".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Depiction(direction) => (
					"depiction".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::NativeDepiction(direction) => (
					"nativeDepiction".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::SileoDepiction(direction) => (
					"sileoDepiction".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Header(direction) => (
					"header".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::TintColor(direction) => (
					"tintColor".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Icon(direction) => (
					"icon".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Section(direction) => (
					"section".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Tags(direction) => (
					"tags".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::InstalledSize(direction) => (
					"installedSize".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		UuidEquals(String),
		Uuid(_prisma::read_filters::StringFilter),
		PackageEquals(String),
		Package(_prisma::read_filters::StringFilter),
		IsCurrentEquals(bool),
		IsPrunedEquals(bool),
		RepositoryTierEquals(i32),
		RepositoryTier(_prisma::read_filters::IntFilter),
		RepositoryIs(Vec<super::repository::WhereParam>),
		RepositoryIsNot(Vec<super::repository::WhereParam>),
		RepositorySlugEquals(String),
		RepositorySlug(_prisma::read_filters::StringFilter),
		PriceEquals(String),
		Price(_prisma::read_filters::StringFilter),
		VersionEquals(String),
		Version(_prisma::read_filters::StringFilter),
		ArchitectureEquals(String),
		Architecture(_prisma::read_filters::StringFilter),
		FilenameEquals(String),
		Filename(_prisma::read_filters::StringFilter),
		SizeEquals(i32),
		Size(_prisma::read_filters::IntFilter),
		Sha256Equals(Option<String>),
		Sha256(_prisma::read_filters::StringFilter),
		NameEquals(Option<String>),
		Name(_prisma::read_filters::StringFilter),
		DescriptionEquals(Option<String>),
		Description(_prisma::read_filters::StringFilter),
		AuthorEquals(Option<String>),
		Author(_prisma::read_filters::StringFilter),
		MaintainerEquals(Option<String>),
		Maintainer(_prisma::read_filters::StringFilter),
		DepictionEquals(Option<String>),
		Depiction(_prisma::read_filters::StringFilter),
		NativeDepictionEquals(Option<String>),
		NativeDepiction(_prisma::read_filters::StringFilter),
		SileoDepictionEquals(Option<String>),
		SileoDepiction(_prisma::read_filters::StringFilter),
		HeaderEquals(Option<String>),
		Header(_prisma::read_filters::StringFilter),
		TintColorEquals(Option<String>),
		TintColor(_prisma::read_filters::StringFilter),
		IconEquals(Option<String>),
		Icon(_prisma::read_filters::StringFilter),
		SectionEquals(Option<String>),
		Section(_prisma::read_filters::StringFilter),
		TagsEquals(Vec<String>),
		Tags(_prisma::read_filters::StringListFilter),
		InstalledSizeEquals(Option<i32>),
		InstalledSize(_prisma::read_filters::IntFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::UuidEquals(value) => (
					"uuid",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Uuid(value) => ("uuid", value.into()),
				Self::PackageEquals(value) => (
					"package",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Package(value) => ("package", value.into()),
				Self::IsCurrentEquals(value) => (
					"isCurrent",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::IsPrunedEquals(value) => (
					"isPruned",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				),
				Self::RepositoryTierEquals(value) => (
					"repositoryTier",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::RepositoryTier(value) => ("repositoryTier", value.into()),
				Self::RepositoryIs(where_params) => (
					"repository",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::RepositoryIsNot(where_params) => (
					"repository",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::RepositorySlugEquals(value) => (
					"repositorySlug",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::RepositorySlug(value) => ("repositorySlug", value.into()),
				Self::PriceEquals(value) => (
					"price",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Price(value) => ("price", value.into()),
				Self::VersionEquals(value) => (
					"version",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Version(value) => ("version", value.into()),
				Self::ArchitectureEquals(value) => (
					"architecture",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Architecture(value) => ("architecture", value.into()),
				Self::FilenameEquals(value) => (
					"filename",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Filename(value) => ("filename", value.into()),
				Self::SizeEquals(value) => (
					"size",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Size(value) => ("size", value.into()),
				Self::Sha256Equals(value) => (
					"sha256",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Sha256(value) => ("sha256", value.into()),
				Self::NameEquals(value) => (
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Name(value) => ("name", value.into()),
				Self::DescriptionEquals(value) => (
					"description",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Description(value) => ("description", value.into()),
				Self::AuthorEquals(value) => (
					"author",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Author(value) => ("author", value.into()),
				Self::MaintainerEquals(value) => (
					"maintainer",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Maintainer(value) => ("maintainer", value.into()),
				Self::DepictionEquals(value) => (
					"depiction",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Depiction(value) => ("depiction", value.into()),
				Self::NativeDepictionEquals(value) => (
					"nativeDepiction",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::NativeDepiction(value) => ("nativeDepiction", value.into()),
				Self::SileoDepictionEquals(value) => (
					"sileoDepiction",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::SileoDepiction(value) => ("sileoDepiction", value.into()),
				Self::HeaderEquals(value) => (
					"header",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Header(value) => ("header", value.into()),
				Self::TintColorEquals(value) => (
					"tintColor",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::TintColor(value) => ("tintColor", value.into()),
				Self::IconEquals(value) => (
					"icon",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Icon(value) => ("icon", value.into()),
				Self::SectionEquals(value) => (
					"section",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Section(value) => ("section", value.into()),
				Self::TagsEquals(value) => (
					"tags",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::Tags(value) => ("tags", value.into()),
				Self::InstalledSizeEquals(value) => (
					"installedSize",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::InstalledSize(value) => ("installedSize", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UuidEquals(String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UuidEquals(value) => Self::UuidEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Package";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			[
				"uuid",
				"package",
				"isCurrent",
				"isPruned",
				"repositoryTier",
				"repositorySlug",
				"price",
				"version",
				"architecture",
				"filename",
				"size",
				"sha256",
				"name",
				"description",
				"author",
				"maintainer",
				"depiction",
				"nativeDepiction",
				"sileoDepiction",
				"header",
				"tintColor",
				"icon",
				"section",
				"tags",
				"installedSize",
			]
			.into_iter()
			.map(|o| {
				let builder = ::prisma_client_rust::Selection::builder(o);
				builder.build()
			})
			.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			package: String,
			is_current: bool,
			repository_tier: i32,
			repository: super::repository::UniqueWhereParam,
			price: String,
			version: String,
			architecture: String,
			filename: String,
			size: i32,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(package::set(package));
			_params.push(is_current::set(is_current));
			_params.push(repository_tier::set(repository_tier));
			_params.push(repository::connect(repository));
			_params.push(price::set(price));
			_params.push(version::set(version));
			_params.push(architecture::set(architecture));
			_params.push(filename::set(filename));
			_params.push(size::set(size));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(
				String,
				bool,
				i32,
				String,
				String,
				String,
				String,
				String,
				i32,
				Vec<SetParam>,
			)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(
					|(
						package,
						is_current,
						repository_tier,
						repository_slug,
						price,
						version,
						architecture,
						filename,
						size,
						mut _params,
					)| {
						_params.push(package::set(package));
						_params.push(is_current::set(is_current));
						_params.push(repository_tier::set(repository_tier));
						_params.push(repository_slug::set(repository_slug));
						_params.push(price::set(price));
						_params.push(version::set(version));
						_params.push(architecture::set(architecture));
						_params.push(filename::set(filename));
						_params.push(size::set(size));
						_params
					},
				)
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(
				package,
				is_current,
				repository_tier,
				repository,
				price,
				version,
				architecture,
				filename,
				size,
				mut _params,
			): (
				String,
				bool,
				i32,
				super::repository::UniqueWhereParam,
				String,
				String,
				String,
				String,
				i32,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(package::set(package));
			_params.push(is_current::set(is_current));
			_params.push(repository_tier::set(repository_tier));
			_params.push(repository::connect(repository));
			_params.push(price::set(price));
			_params.push(version::set(version));
			_params.push(architecture::set(architecture));
			_params.push(filename::set(filename));
			_params.push(size::set(size));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod cache {
	use super::_prisma::*;
	use super::*;
	pub mod uuid {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UuidEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Uuid(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Uuid(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUuid(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Uuid(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uuid").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Uuid(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("uuid").build()
			}
		}
	}
	pub mod file_hash {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::FileHashEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::FileHash(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::FileHash(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetFileHash(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FileHash(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("fileHash").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FileHash(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("fileHash").build()
			}
		}
	}
	pub mod repository_slug {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::RepositorySlugEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::RepositorySlug(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::RepositorySlug(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetRepositorySlug(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RepositorySlug(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("repositorySlug").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RepositorySlug(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("repositorySlug").build()
			}
		}
	}
	pub fn create(
		file_hash: String,
		repository_slug: String,
		_params: Vec<SetParam>,
	) -> (String, String, Vec<SetParam>) {
		(file_hash, repository_slug, _params)
	}
	pub fn create_unchecked(
		file_hash: String,
		repository_slug: String,
		_params: Vec<SetParam>,
	) -> (String, String, Vec<SetParam>) {
		(file_hash, repository_slug, _params)
	}
	#[macro_export]
	macro_rules ! _select_cache { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: cache :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: cache :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: cache :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: cache :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: cache :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: cache :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { uuid , file_hash , repository_slug } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: cache :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: cache :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: cache :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: cache :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: cache :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: cache :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["uuid" , "fileHash" , "repositorySlug"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: cache :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; uuid) => { String } ; (@ field_type ; file_hash) => { String } ; (@ field_type ; repository_slug) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Cache" , available fields are "uuid, file_hash, repository_slug")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; uuid) => { Into :: < $ crate :: prisma :: cache :: SelectParam > :: into ($ crate :: prisma :: cache :: uuid :: Select) } ; (@ selection_field_to_selection_param ; file_hash) => { Into :: < $ crate :: prisma :: cache :: SelectParam > :: into ($ crate :: prisma :: cache :: file_hash :: Select) } ; (@ selection_field_to_selection_param ; repository_slug) => { Into :: < $ crate :: prisma :: cache :: SelectParam > :: into ($ crate :: prisma :: cache :: repository_slug :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: cache :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; file_hash) => { "fileHash" } ; (@ field_serde_name ; repository_slug) => { "repositorySlug" } ; }
	pub use _select_cache as select;
	pub enum SelectParam {
		Uuid(uuid::Select),
		FileHash(file_hash::Select),
		RepositorySlug(repository_slug::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Uuid(data) => data.to_selection(),
				Self::FileHash(data) => data.to_selection(),
				Self::RepositorySlug(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_cache { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: cache :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: cache :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: cache :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: cache :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: cache :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: cache :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: cache :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: cache :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub uuid : String , pub file_hash : String , pub repository_slug : String , $ (pub $ field : $ crate :: prisma :: cache :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (uuid) , stringify ! (file_hash) , stringify ! (repository_slug)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; uuid) , & self . uuid) ? ; state . serialize_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; file_hash) , & self . file_hash) ? ; state . serialize_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; repository_slug) , & self . repository_slug) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , uuid , file_hash , repository_slug } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: cache :: include ! (@ field_serde_name ; uuid) , ", " , $ crate :: prisma :: cache :: include ! (@ field_serde_name ; file_hash) , ", " , $ crate :: prisma :: cache :: include ! (@ field_serde_name ; repository_slug) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: cache :: include ! (@ field_serde_name ; uuid) => Ok (Field :: uuid) , $ crate :: prisma :: cache :: include ! (@ field_serde_name ; file_hash) => Ok (Field :: file_hash) , $ crate :: prisma :: cache :: include ! (@ field_serde_name ; repository_slug) => Ok (Field :: repository_slug) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut uuid = None ; let mut file_hash = None ; let mut repository_slug = None ; while let Some (key) = map . next_key () ? { match key { Field :: uuid => { if uuid . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; uuid))) ; } uuid = Some (map . next_value () ?) ; } Field :: file_hash => { if file_hash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; file_hash))) ; } file_hash = Some (map . next_value () ?) ; } Field :: repository_slug => { if repository_slug . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; repository_slug))) ; } repository_slug = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; $ field))) ? ;) * let uuid = uuid . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; uuid))) ? ; let file_hash = file_hash . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; file_hash))) ? ; let repository_slug = repository_slug . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: cache :: include ! (@ field_serde_name ; repository_slug))) ? ; Ok (Data { uuid , file_hash , repository_slug , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["uuid" , "fileHash" , "repositorySlug"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: cache :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Cache" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: cache :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; file_hash) => { "fileHash" } ; (@ field_serde_name ; repository_slug) => { "repositorySlug" } ; }
	pub use _include_cache as include;
	pub enum IncludeParam {
		Uuid(uuid::Include),
		FileHash(file_hash::Include),
		RepositorySlug(repository_slug::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Uuid(data) => data.to_selection(),
				Self::FileHash(data) => data.to_selection(),
				Self::RepositorySlug(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "uuid")]
		pub uuid: String,
		#[serde(rename = "fileHash")]
		pub file_hash: String,
		#[serde(rename = "repositorySlug")]
		pub repository_slug: String,
	}
	impl Data {}
	#[derive(Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetUuid(String),
		SetFileHash(String),
		SetRepositorySlug(String),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetUuid(value) => (
					"uuid".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetFileHash(value) => (
					"fileHash".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetRepositorySlug(value) => (
					"repositorySlug".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Uuid(::prisma_client_rust::Direction),
		FileHash(::prisma_client_rust::Direction),
		RepositorySlug(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Uuid(direction) => (
					"uuid".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::FileHash(direction) => (
					"fileHash".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::RepositorySlug(direction) => (
					"repositorySlug".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		UuidEquals(String),
		Uuid(_prisma::read_filters::StringFilter),
		FileHashEquals(String),
		FileHash(_prisma::read_filters::StringFilter),
		RepositorySlugEquals(String),
		RepositorySlug(_prisma::read_filters::StringFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::UuidEquals(value) => (
					"uuid",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Uuid(value) => ("uuid", value.into()),
				Self::FileHashEquals(value) => (
					"fileHash",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::FileHash(value) => ("fileHash", value.into()),
				Self::RepositorySlugEquals(value) => (
					"repositorySlug",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::RepositorySlug(value) => ("repositorySlug", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UuidEquals(String),
		RepositorySlugEquals(String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UuidEquals(value) => Self::UuidEquals(value),
				UniqueWhereParam::RepositorySlugEquals(value) => Self::RepositorySlugEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Cache";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["uuid", "fileHash", "repositorySlug"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			file_hash: String,
			repository_slug: String,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(file_hash::set(file_hash));
			_params.push(repository_slug::set(repository_slug));
			Create::new(self.client, _params)
		}
		pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(file_hash, repository_slug, mut _params)| {
					_params.push(file_hash::set(file_hash));
					_params.push(repository_slug::set(repository_slug));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(file_hash, repository_slug, mut _params): (String, String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(file_hash::set(file_hash));
			_params.push(repository_slug::set(repository_slug));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClientBuilder {
		url: Option<String>,
		action_notifier: ::prisma_client_rust::ActionNotifier,
	}
	impl PrismaClientBuilder {
		pub fn new() -> Self {
			Self {
				url: None,
				action_notifier: ::prisma_client_rust::ActionNotifier::new(),
			}
		}
		pub fn with_url(mut self, url: String) -> Self {
			self.url = Some(url);
			self
		}
		pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
			let config =
				::prisma_client_rust::datamodel::parse_configuration(super::DATAMODEL_STR)?.subject;
			let source = config
				.datasources
				.first()
				.expect("Please supply a datasource in your schema.prisma file");
			let url = match self.url {
				Some(url) => url,
				None => {
					let url = if let Some(url) = source.load_shadow_database_url()? {
						url
					} else {
						source.load_url(|key| std::env::var(key).ok())?
					};
					match url.starts_with("file:") {
						true => {
							let path = url.split(":").nth(1).unwrap();
							if std::path::Path::new("./prisma/schema.prisma").exists() {
								format!("file:./prisma/{}", path)
							} else {
								url
							}
						}
						_ => url,
					}
				}
			};
			let (db_name, executor) =
				::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
			let internal_model =
				::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(
					super::DATAMODEL_STR,
				)
				.build(db_name);
			let query_schema =
				std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
					internal_model,
					true,
					source.capabilities(),
					vec![],
					source.referential_integrity(),
				));
			executor.primary_connector().get_connection().await?;
			Ok(PrismaClient(::prisma_client_rust::PrismaClientInternals {
				executor,
				query_schema,
				url,
				action_notifier: self.action_notifier,
			}))
		}
	}
	pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub fn _builder() -> PrismaClientBuilder {
			PrismaClientBuilder::new()
		}
		pub fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::Result<T::ReturnType> {
			::prisma_client_rust::batch(queries, &self.0).await
		}
		pub fn repository(&self) -> super::repository::Actions {
			super::repository::Actions { client: &self.0 }
		}
		pub fn origin(&self) -> super::origin::Actions {
			super::origin::Actions { client: &self.0 }
		}
		pub fn package(&self) -> super::package::Actions {
			super::package::Actions { client: &self.0 }
		}
		pub fn cache(&self) -> super::cache::Actions {
			super::cache::Actions { client: &self.0 }
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum CacheScalarFieldEnum {
		#[serde(rename = "uuid")]
		Uuid,
		#[serde(rename = "fileHash")]
		FileHash,
		#[serde(rename = "repositorySlug")]
		RepositorySlug,
	}
	impl ToString for CacheScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Uuid => "uuid".to_string(),
				Self::FileHash => "fileHash".to_string(),
				Self::RepositorySlug => "repositorySlug".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum OriginScalarFieldEnum {
		#[serde(rename = "uuid")]
		Uuid,
		#[serde(rename = "hostname")]
		Hostname,
		#[serde(rename = "releasePath")]
		ReleasePath,
		#[serde(rename = "packagesPath")]
		PackagesPath,
		#[serde(rename = "lastUpdated")]
		LastUpdated,
		#[serde(rename = "hasInRelease")]
		HasInRelease,
		#[serde(rename = "hasReleaseGpg")]
		HasReleaseGpg,
		#[serde(rename = "supportsPaymentV1")]
		SupportsPaymentV1,
		#[serde(rename = "supportsPaymentV2")]
		SupportsPaymentV2,
		#[serde(rename = "usesHttps")]
		UsesHttps,
	}
	impl ToString for OriginScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Uuid => "uuid".to_string(),
				Self::Hostname => "hostname".to_string(),
				Self::ReleasePath => "releasePath".to_string(),
				Self::PackagesPath => "packagesPath".to_string(),
				Self::LastUpdated => "lastUpdated".to_string(),
				Self::HasInRelease => "hasInRelease".to_string(),
				Self::HasReleaseGpg => "hasReleaseGpg".to_string(),
				Self::SupportsPaymentV1 => "supportsPaymentV1".to_string(),
				Self::SupportsPaymentV2 => "supportsPaymentV2".to_string(),
				Self::UsesHttps => "usesHttps".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum PackageScalarFieldEnum {
		#[serde(rename = "uuid")]
		Uuid,
		#[serde(rename = "package")]
		Package,
		#[serde(rename = "isCurrent")]
		IsCurrent,
		#[serde(rename = "isPruned")]
		IsPruned,
		#[serde(rename = "repositoryTier")]
		RepositoryTier,
		#[serde(rename = "repositorySlug")]
		RepositorySlug,
		#[serde(rename = "price")]
		Price,
		#[serde(rename = "version")]
		Version,
		#[serde(rename = "architecture")]
		Architecture,
		#[serde(rename = "filename")]
		Filename,
		#[serde(rename = "size")]
		Size,
		#[serde(rename = "sha256")]
		Sha256,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "description")]
		Description,
		#[serde(rename = "author")]
		Author,
		#[serde(rename = "maintainer")]
		Maintainer,
		#[serde(rename = "depiction")]
		Depiction,
		#[serde(rename = "nativeDepiction")]
		NativeDepiction,
		#[serde(rename = "sileoDepiction")]
		SileoDepiction,
		#[serde(rename = "header")]
		Header,
		#[serde(rename = "tintColor")]
		TintColor,
		#[serde(rename = "icon")]
		Icon,
		#[serde(rename = "section")]
		Section,
		#[serde(rename = "tags")]
		Tags,
		#[serde(rename = "installedSize")]
		InstalledSize,
	}
	impl ToString for PackageScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Uuid => "uuid".to_string(),
				Self::Package => "package".to_string(),
				Self::IsCurrent => "isCurrent".to_string(),
				Self::IsPruned => "isPruned".to_string(),
				Self::RepositoryTier => "repositoryTier".to_string(),
				Self::RepositorySlug => "repositorySlug".to_string(),
				Self::Price => "price".to_string(),
				Self::Version => "version".to_string(),
				Self::Architecture => "architecture".to_string(),
				Self::Filename => "filename".to_string(),
				Self::Size => "size".to_string(),
				Self::Sha256 => "sha256".to_string(),
				Self::Name => "name".to_string(),
				Self::Description => "description".to_string(),
				Self::Author => "author".to_string(),
				Self::Maintainer => "maintainer".to_string(),
				Self::Depiction => "depiction".to_string(),
				Self::NativeDepiction => "nativeDepiction".to_string(),
				Self::SileoDepiction => "sileoDepiction".to_string(),
				Self::Header => "header".to_string(),
				Self::TintColor => "tintColor".to_string(),
				Self::Icon => "icon".to_string(),
				Self::Section => "section".to_string(),
				Self::Tags => "tags".to_string(),
				Self::InstalledSize => "installedSize".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum QueryMode {
		#[serde(rename = "default")]
		Default,
		#[serde(rename = "insensitive")]
		Insensitive,
	}
	impl ToString for QueryMode {
		fn to_string(&self) -> String {
			match self {
				Self::Default => "default".to_string(),
				Self::Insensitive => "insensitive".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum RepositoryScalarFieldEnum {
		#[serde(rename = "slug")]
		Slug,
		#[serde(rename = "aliases")]
		Aliases,
		#[serde(rename = "tier")]
		Tier,
		#[serde(rename = "packageCount")]
		PackageCount,
		#[serde(rename = "sections")]
		Sections,
		#[serde(rename = "uri")]
		Uri,
		#[serde(rename = "suite")]
		Suite,
		#[serde(rename = "component")]
		Component,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "version")]
		Version,
		#[serde(rename = "description")]
		Description,
		#[serde(rename = "date")]
		Date,
		#[serde(rename = "paymentGateway")]
		PaymentGateway,
		#[serde(rename = "sileoEndpoint")]
		SileoEndpoint,
		#[serde(rename = "isPruned")]
		IsPruned,
		#[serde(rename = "originId")]
		OriginId,
	}
	impl ToString for RepositoryScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Slug => "slug".to_string(),
				Self::Aliases => "aliases".to_string(),
				Self::Tier => "tier".to_string(),
				Self::PackageCount => "packageCount".to_string(),
				Self::Sections => "sections".to_string(),
				Self::Uri => "uri".to_string(),
				Self::Suite => "suite".to_string(),
				Self::Component => "component".to_string(),
				Self::Name => "name".to_string(),
				Self::Version => "version".to_string(),
				Self::Description => "description".to_string(),
				Self::Date => "date".to_string(),
				Self::PaymentGateway => "paymentGateway".to_string(),
				Self::SileoEndpoint => "sileoEndpoint".to_string(),
				Self::IsPruned => "isPruned".to_string(),
				Self::OriginId => "originId".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "ReadUncommitted")]
		ReadUncommitted,
		#[serde(rename = "ReadCommitted")]
		ReadCommitted,
		#[serde(rename = "RepeatableRead")]
		RepeatableRead,
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::ReadUncommitted => "ReadUncommitted".to_string(),
				Self::ReadCommitted => "ReadCommitted".to_string(),
				Self::RepeatableRead => "RepeatableRead".to_string(),
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	pub mod read_filters {
		use super::*;
		#[derive(Clone)]
		pub enum StringListFilter {
			Has(String),
			HasEvery(Vec<String>),
			HasSome(Vec<String>),
			IsEmpty(bool),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringListFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"has".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::HasEvery(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"hasEvery".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::HasSome(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"hasSome".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::IsEmpty(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"isEmpty".to_string(),
							::prisma_client_rust::PrismaValue::Boolean(value),
						)])
					}
				}
			}
		}
		#[derive(Clone)]
		pub enum StringFilter {
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Mode(QueryMode),
			Not(String),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Mode(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"mode".to_string(),
							::prisma_client_rust::PrismaValue::Enum(value.to_string()),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum IntFilter {
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(i32),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum DateTimeFilter {
			InVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			NotInVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				}
			}
		}
	}
}
pub use _prisma::PrismaClient;
